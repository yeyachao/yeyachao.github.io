<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World（摘抄意林）</title>
    <url>/2024/10/11/my/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>看完《强风吹拂》这部动漫，不禁想到了经典动漫《起风了》里面的台词：</p>
<p><strong>“纵有疾风起，人生不言弃”</strong></p>
<p>《强风吹拂》向我们传达的也是一种突破自我的坚持</p>
<p>箱根驿传一路崎岖坎坷，这何尝不是人生之路的真实写照呢？</p>
<p>其实我们的人生并不是在平坦的赛道上前行，从升学毕业到结婚成家</p>
<p>每一个人生转折点就如箱根驿传上的一个接力点，下一段也许会更加坚信</p>
<span id="more"></span>
<p>但这一路有幸与亲人朋友们相互支持、相互鼓舞，我们便可强大到去战胜面前的困难，亦可战胜自己内心的胆怯</p>
<p>在人生的道路上迎难而上，步履不停地去追求心中的目标!</p>
]]></content>
  </entry>
  <entry>
    <title>电工</title>
    <url>/2024/11/28/%E7%94%B5%E6%B0%94/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1-电学基础"><a href="#1-电学基础" class="headerlink" title="1.电学基础"></a><strong>1.电学基础</strong></h3><h5 id="电压电流电阻"><a href="#电压电流电阻" class="headerlink" title="电压电流电阻"></a>电压电流电阻</h5><p>电压（Voltage, V）：电压是推动电流流动的“动力”。单位是伏特（V）。电压通常由电源（如电池或发电机）提供。<br>电流（Current, I）：电流是电子在导体中的流动。单位是安培（A）。电流的大小取决于电压和电阻。<br>电阻（Resistance, R）：电阻是物体对电流流动的阻碍，单位是欧姆（Ω）。导体的材料、电长度、截面积都会影响电阻。<br>功率（Power, P）：电功率是电能转化为其他形式能量的速率。单位是瓦特（W）。</p>
<p>功率与电压和电流相关。<br>公式：<br><mjx-container class="MathJax" jax="SVG" display="true" width="full" style="min-width: 23.285ex;"><svg style="vertical-align: -0.566ex; min-width: 23.285ex;" xmlns="http://www.w3.org/2000/svg" width="100%" height="2.262ex" role="img" focusable="false"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(0.0181,-0.0181) translate(0, -750)"><g data-mml-node="math"><g data-mml-node="mtable" transform="translate(2856,0) translate(-2856,0)"><g transform="translate(0 750) matrix(1 0 0 -1 0 0) scale(55.25)"><svg data-table="true" preserveAspectRatio="xMidYMid" viewBox="2290 -750 1 1000"><g transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mlabeledtr"><g data-mml-node="mtd"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(1028.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2084.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="mo" transform="translate(3075.8,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(4076,0)"><path data-c="1D43C" d="M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z"></path></g></g></g></g></svg><svg data-labels="true" preserveAspectRatio="xMaxYMid" viewBox="2056 -750 1 1000"><g data-labels="true" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mtd" id="mjx-eqn:1.1"><g data-mml-node="mtext"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(389,0)"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(889,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(1167,0)"></path><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" transform="translate(1667,0)"></path></g></g></g></svg></g></g></g></g></svg></mjx-container><br>功率与电阻和电流的关系：<br><mjx-container class="MathJax" jax="SVG" display="true" width="full" style="min-width: 24.37ex;"><svg style="vertical-align: -0.717ex; min-width: 24.37ex;" xmlns="http://www.w3.org/2000/svg" width="100%" height="2.565ex" role="img" focusable="false"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(0.0181,-0.0181) translate(0, -817)"><g data-mml-node="math"><g data-mml-node="mtable" transform="translate(2856,0) translate(-2856,0)"><g transform="translate(0 817) matrix(1 0 0 -1 0 0) scale(55.25)"><svg data-table="true" preserveAspectRatio="xMidYMid" viewBox="2529.9 -817 1 1133.9"><g transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mlabeledtr" transform="translate(0,-67)"><g data-mml-node="mtd"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(1028.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msup" transform="translate(2084.6,0)"><g data-mml-node="mi"><path data-c="1D43C" d="M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z"></path></g><g data-mml-node="mn" transform="translate(590.2,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(3300.5,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(4300.8,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g></g></g></g></svg><svg data-labels="true" preserveAspectRatio="xMaxYMid" viewBox="2056 -817 1 1133.9"><g data-labels="true" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mtd" id="mjx-eqn:1.2" transform="translate(0,683)"><text data-id-align="true"></text><g data-idbox="true" transform="translate(0,-750)"><g data-mml-node="mtext"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(389,0)"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(889,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1167,0)"></path><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" transform="translate(1667,0)"></path></g></g></g></g></svg></g></g></g></g></svg></mjx-container><br>功率与电压和电阻的关系：<br><mjx-container class="MathJax" jax="SVG" display="true" width="full" style="min-width: 21.496ex;"><svg style="vertical-align: -1.942ex; min-width: 21.496ex;" xmlns="http://www.w3.org/2000/svg" width="100%" height="5.016ex" role="img" focusable="false"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(0.0181,-0.0181) translate(0, -1358.5)"><g data-mml-node="math"><g data-mml-node="mtable" transform="translate(2856,0) translate(-2856,0)"><g transform="translate(0 1358.5) matrix(1 0 0 -1 0 0) scale(55.25)"><svg data-table="true" preserveAspectRatio="xMidYMid" viewBox="1894.7 -1358.5 1 2216.9"><g transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mlabeledtr" transform="translate(0,-151.5)"><g data-mml-node="mtd"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(1028.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(2084.6,0)"><g data-mml-node="msup" transform="translate(220,676)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="mn" transform="translate(861.3,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mi" transform="translate(472.9,-686)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><rect width="1464.9" height="60" x="120" y="220"></rect></g></g></g></g></svg><svg data-labels="true" preserveAspectRatio="xMaxYMid" viewBox="2056 -1358.5 1 2216.9"><g data-labels="true" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mtd" id="mjx-eqn:1.3" transform="translate(0,598.5)"><text data-id-align="true"></text><g data-idbox="true" transform="translate(0,-750)"><g data-mml-node="mtext"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(389,0)"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(889,0)"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(1167,0)"></path><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" transform="translate(1667,0)"></path></g></g></g></g></svg></g></g></g></g></svg></mjx-container></p>
<h5 id="欧姆定律（Ohm’s-Law）"><a href="#欧姆定律（Ohm’s-Law）" class="headerlink" title="欧姆定律（Ohm’s Law）"></a><strong>欧姆定律</strong>（Ohm’s Law）</h5><p>欧姆定律是电路分析的基础，表明电流与电压成正比，与电阻成反比。公式为：<br><mjx-container class="MathJax" jax="SVG" display="true" width="full" style="min-width: 19.816ex;"><svg style="vertical-align: -1.771ex; min-width: 19.816ex;" xmlns="http://www.w3.org/2000/svg" width="100%" height="4.674ex" role="img" focusable="false"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(0.0181,-0.0181) translate(0, -1283)"><g data-mml-node="math"><g data-mml-node="mtable" transform="translate(2856,0) translate(-2856,0)"><g transform="translate(0 1283) matrix(1 0 0 -1 0 0) scale(55.25)"><svg data-table="true" preserveAspectRatio="xMidYMid" viewBox="1523.3 -1283 1 2066"><g transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mlabeledtr" transform="translate(0,-76)"><g data-mml-node="mtd"><g data-mml-node="mi"><path data-c="1D43C" d="M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z"></path></g><g data-mml-node="mo" transform="translate(781.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(1837.6,0)"><g data-mml-node="mi" transform="translate(220,676)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="mi" transform="translate(225,-686)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><rect width="969" height="60" x="120" y="220"></rect></g></g></g></g></svg><svg data-labels="true" preserveAspectRatio="xMaxYMid" viewBox="2056 -1283 1 2066"><g data-labels="true" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mtd" id="mjx-eqn:2.1" transform="translate(0,674)"><text data-id-align="true"></text><g data-idbox="true" transform="translate(0,-750)"><g data-mml-node="mtext"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(389,0)"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(889,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(1167,0)"></path><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" transform="translate(1667,0)"></path></g></g></g></g></svg></g></g></g></g></svg></mjx-container></p>
<p>I：电流（安培，A）<br>V：电压（伏特，V）<br>R：电阻（欧姆，Ω）</p>
<h5 id="常用电气元件"><a href="#常用电气元件" class="headerlink" title="常用电气元件"></a>常用电气元件</h5><p>电池（Battery）：提供电压，常见电池有干电池、蓄电池、铅酸电池等。<br>电阻（Resistor）：控制电流大小，常用于调节电流。<br>电容器（Capacitor）：储存电荷，可以暂时储存电能并释放出来。<br>电感器（Inductor）：储存能量并限制电流的变化。<br>二极管（Diode）：允许电流单方向流动，常用于整流电路中。<br>晶体管（Transistor）：用于放大电信号，也可以作为开关元件。<br>开关（Switch）：用于控制电流的开闭。</p>
<h5 id="常见电气单位"><a href="#常见电气单位" class="headerlink" title="常见电气单位"></a>常见电气单位</h5><p>电压（V, Volt）：电位差的单位，常用单位是伏特（V）。<br>电流（A, Ampere）：电流单位，常用单位是安培（A）。<br>电阻（Ω, Ohm）：电阻单位，常用单位是欧姆（Ω）。<br>功率（W, Watt）：功率单位，常用单位是瓦特（W）。</p>
<h5 id="电路基本类型"><a href="#电路基本类型" class="headerlink" title="电路基本类型"></a>电路基本类型</h5><p>串联电路：电路中的元件连接在一起，电流必须通过每个元件。总电阻是各元件电阻之和。<br>串联电阻计算：<br><mjx-container class="MathJax" jax="SVG" display="true" width="full" style="min-width: 38.508ex;"><svg style="vertical-align: -0.643ex; min-width: 38.508ex;" xmlns="http://www.w3.org/2000/svg" width="100%" height="2.417ex" role="img" focusable="false"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(0.0181,-0.0181) translate(0, -784.1)"><g data-mml-node="math"><g data-mml-node="mtable" transform="translate(2856,0) translate(-2856,0)"><g transform="translate(0 784.1) matrix(1 0 0 -1 0 0) scale(55.25)"><svg data-table="true" preserveAspectRatio="xMidYMid" viewBox="5654.3 -784.1 1 1068.2"><g transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mlabeledtr" transform="translate(0,34.1)"><g data-mml-node="mtd"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="TeXAtom" transform="translate(792,-176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">总</text></g></g></g><g data-mml-node="mo" transform="translate(1826.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msub" transform="translate(2882.7,0)"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(4300.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="msub" transform="translate(5300.7,0)"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(6718.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="msub" transform="translate(7718.7,0)"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g><g data-mml-node="mo" transform="translate(9136.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(10136.7,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g></g></g></g></svg><svg data-labels="true" preserveAspectRatio="xMaxYMid" viewBox="2056 -784.1 1 1068.2"><g data-labels="true" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mtd" id="mjx-eqn:3.1" transform="translate(0,784.1)"><text data-id-align="true"></text><g data-idbox="true" transform="translate(0,-750)"><g data-mml-node="mtext"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(389,0)"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(889,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(1167,0)"></path><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" transform="translate(1667,0)"></path></g></g></g></g></svg></g></g></g></g></svg></mjx-container><br>串联电流：电流在每个元件中相同。<br>并联电路：电路中的元件并排连接，电流可以选择不同路径流动。总电阻小于任何一个单独的电阻。<br>并联电阻计算：<br><mjx-container class="MathJax" jax="SVG" display="true" width="full" style="min-width: 42.49ex;"><svg style="vertical-align: -2.088ex; min-width: 42.49ex;" xmlns="http://www.w3.org/2000/svg" width="100%" height="5.308ex" role="img" focusable="false"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(0.0181,-0.0181) translate(0, -1423.1)"><g data-mml-node="math"><g data-mml-node="mtable" transform="translate(2856,0) translate(-2856,0)"><g transform="translate(0 1423.1) matrix(1 0 0 -1 0 0) scale(55.25)"><svg data-table="true" preserveAspectRatio="xMidYMid" viewBox="6534.3 -1423.1 1 2346.2"><g transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mlabeledtr" transform="translate(0,81.1)"><g data-mml-node="mtd"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(744.6,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="msub" transform="translate(220,-686)"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="TeXAtom" transform="translate(792,-176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">总</text></g></g></g><rect width="1749.1" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(2266.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(3322.7,0)"><g data-mml-node="mn" transform="translate(567.8,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="msub" transform="translate(220,-686)"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><rect width="1395.6" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(5180.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mfrac" transform="translate(6180.7,0)"><g data-mml-node="mn" transform="translate(567.8,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="msub" transform="translate(220,-686)"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><rect width="1395.6" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(8038.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mfrac" transform="translate(9038.7,0)"><g data-mml-node="mn" transform="translate(567.8,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="msub" transform="translate(220,-686)"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g><rect width="1395.6" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(10896.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(11896.7,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g></g></g></g></svg><svg data-labels="true" preserveAspectRatio="xMaxYMid" viewBox="2056 -1423.1 1 2346.2"><g data-labels="true" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="mtd" id="mjx-eqn:3.2" transform="translate(0,831.1)"><text data-id-align="true"></text><g data-idbox="true" transform="translate(0,-750)"><g data-mml-node="mtext"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(389,0)"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(889,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1167,0)"></path><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" transform="translate(1667,0)"></path></g></g></g></g></svg></g></g></g></g></svg></mjx-container><br>并联电压：每个元件两端的电压相同。</p>
<h5 id="电路中的安全问题"><a href="#电路中的安全问题" class="headerlink" title="电路中的安全问题"></a>电路中的安全问题</h5><p>电击（Electric Shock）：如果人直接或间接接触到电源的带电部分，电流可能通过人体，造成电击。为了防止电击，电气系统需要接地和绝缘。<br>电气火灾（Electrical Fire）：由于电路过载、短路或绝缘故障可能导致火灾。使用合格的电器、定期检查电气设备和线路能减少火灾的发生。<br>过载保护（Overload Protection）：通过断路器、熔断器等设备来保护电路不受过载损害。</p>
<h5 id="电气工具和测量仪器"><a href="#电气工具和测量仪器" class="headerlink" title="电气工具和测量仪器"></a>电气工具和测量仪器</h5><p>万用表（Multimeter）：用于测量电压、电流、电阻等基本电气量。<br>测量电压：设置为“V”，测量电源两端的电压。<br>测量电流：设置为“A”，将表笔串联到电路中，测量电流。<br>测量电阻：设置为“Ω”，用来检查电路的电阻。<br>电笔（Test Pen）：用于检测电源是否带电，通常用于简单的电压检查。<br>钳形表（Clamp Meter）：用于测量电流，尤其适用于需要测量大电流时。</p>
<h5 id="电气安装基础"><a href="#电气安装基础" class="headerlink" title="电气安装基础"></a>电气安装基础</h5><p>布线：根据电流负荷和使用环境选择合适的电线规格，常见电线有单股铜线、多股铜线、铝线等。<br>电气设备接地：为了防止电气设备漏电带电，必须通过接地系统进行接地。<br>电源插座和开关：插座和开关的选用要根据负载功率、使用频率和安全性来决定。</p>
<h5 id="常见电工术语"><a href="#常见电工术语" class="headerlink" title="常见电工术语"></a>常见电工术语</h5><p>直流电（DC, Direct Current）：电流方向恒定不变，常见于电池、太阳能电池等。<br>交流电（AC, Alternating Current）：电流方向周期性变化，常见于家庭用电。<br>短路（Short Circuit）：电流绕过负载流动，造成电路中电流急剧增大，可能导致损坏设备或起火。<br>接地（Grounding）：通过接地线将电气设备与地面连接，以防止设备漏电时电流通过人身。<br>负载（Load）：电路中消耗电能的部分，通常指电器、灯泡等。</p>
<h3 id="2-电线种类分类"><a href="#2-电线种类分类" class="headerlink" title="2.电线种类分类"></a><strong>2.电线种类分类</strong></h3><p>电线的分类通常根据以下几个标准来进行：</p>
<h4 id="1-按导体材料分类"><a href="#1-按导体材料分类" class="headerlink" title="(1) 按导体材料分类"></a>(1) <strong>按导体材料分类</strong></h4><ul>
<li><strong>铜线</strong>（Cu）：铜导体是最常用的导电材料，具有良好的导电性和延展性，广泛用于家庭、工业和商业的电力传输。<ul>
<li><strong>优点</strong>：导电性好，抗腐蚀，延展性强，能够长时间稳定使用。</li>
<li><strong>缺点</strong>：价格较高。</li>
</ul>
</li>
<li><strong>铝线</strong>（Al）：铝导体的电线比铜线便宜，轻便，但导电性较差，容易受温度变化影响，适用于负荷较低的电力传输。<ul>
<li><strong>优点</strong>：价格便宜，重量轻。</li>
<li><strong>缺点</strong>：导电性能不如铜线，容易产生接触电阻。</li>
</ul>
</li>
</ul>
<h4 id="2-按结构分类"><a href="#2-按结构分类" class="headerlink" title="(2) 按结构分类"></a>(2) <strong>按结构分类</strong></h4><ul>
<li><p>单股线</p>
<p>：由一根导体线组成，常用于电气设备内部连接或导线较短的地方。结构简单，适用于不经常弯曲的场合。</p>
<ul>
<li><strong>常见应用</strong>：家庭电路、开关线路等。</li>
</ul>
</li>
<li><p>多股线</p>
<p>：由多根细铜线或铝线组成，弯曲性强，适合需要经常移动、振动或弯曲的场所。</p>
<ul>
<li><strong>常见应用</strong>：电动工具电缆、家用电器连接线等。</li>
</ul>
</li>
</ul>
<h4 id="3-按绝缘材料分类"><a href="#3-按绝缘材料分类" class="headerlink" title="(3) 按绝缘材料分类"></a>(3) <strong>按绝缘材料分类</strong></h4><ul>
<li><strong>PVC线（聚氯乙烯线）</strong>：绝缘层采用聚氯乙烯（PVC）材料，适用于室内普通环境，防潮、耐油性差，通常用于家庭电路。<ul>
<li><strong>特点</strong>：抗氧化、耐腐蚀、绝缘性能好，常见的家用电线。</li>
</ul>
</li>
<li><strong>XLPE线（交联聚乙烯线）</strong>：具有更高的耐热性、抗老化性，通常用于高温环境下。<ul>
<li><strong>特点</strong>：高温、高压环境下使用，耐腐蚀，适用于工业环境。</li>
</ul>
</li>
<li><strong>橡胶线</strong>：用于要求柔软、耐高温、抗压的场所。常用于电气设备的连接线，尤其是大功率电器。<ul>
<li><strong>特点</strong>：柔软、耐热，适合长期弯曲使用。</li>
</ul>
</li>
</ul>
<h4 id="4-按电压等级分类"><a href="#4-按电压等级分类" class="headerlink" title="(4) 按电压等级分类"></a>(4) <strong>按电压等级分类</strong></h4><ul>
<li><strong>低压电线</strong>：通常适用于220V和380V以下的电力系统，如家庭电力、电动工具等。<ul>
<li><strong>常见电压等级</strong>：0.6/1kV。</li>
</ul>
</li>
<li><strong>中压电线</strong>：适用于1kV至35kV的电力系统，通常用于变电站到用户之间的电力传输。<ul>
<li><strong>常见电压等级</strong>：10kV、20kV、35kV。</li>
</ul>
</li>
<li><strong>高压电线</strong>：适用于35kV以上的电力传输线路。<ul>
<li><strong>常见电压等级</strong>：110kV、220kV、500kV。</li>
</ul>
</li>
</ul>
<h4 id="5-按用途分类"><a href="#5-按用途分类" class="headerlink" title="(5) 按用途分类"></a>(5) <strong>按用途分类</strong></h4><ul>
<li><strong>电力电缆</strong>：用于电力传输，一般采用铜或铝导体，外层有绝缘和护套，适合于输电、配电系统。</li>
<li><strong>控制电缆</strong>：用于连接电气设备进行控制和信号传输，通常采用多股线，并具有良好的抗干扰能力。</li>
<li><strong>通讯电缆</strong>：用于通信系统，如电话线、网络线等，通常采用屏蔽结构以降低干扰。</li>
<li><strong>信号电缆</strong>：用于低电压信号的传输，比如音频、视频信号等。</li>
</ul>
<h3 id="3-电气名称（电缆的标识和命名规则）"><a href="#3-电气名称（电缆的标识和命名规则）" class="headerlink" title="3. 电气名称（电缆的标识和命名规则）"></a>3. <strong>电气名称（电缆的标识和命名规则）</strong></h3><p>电缆或电线的名称通常遵循特定的命名规则，表示其结构、材料、用途等。以下是常见的电气电缆命名规则和一些常见名称的解释：</p>
<h4 id="1-常见的电缆标识结构"><a href="#1-常见的电缆标识结构" class="headerlink" title="(1) 常见的电缆标识结构"></a>(1) <strong>常见的电缆标识结构</strong></h4><p>电缆的标识通常由字母和数字组合而成，不同的字母代表不同的含义。以下是常见字母的解释：</p>
<ul>
<li><strong>Y</strong>：指PVC绝缘。</li>
<li><strong>B</strong>：表示带有加强护套（防护层）。</li>
<li><strong>X</strong>：交联聚乙烯（XLPE）绝缘。</li>
<li><strong>Z</strong>：阻燃型。</li>
<li><strong>F</strong>：氟塑料绝缘。</li>
<li><strong>L</strong>：表示铜芯电缆。</li>
<li><strong>S</strong>：表示钢芯（或钢丝）加固护套。</li>
<li><strong>W</strong>：表示具有防水性能。</li>
</ul>
<h4 id="2-电缆标识示例"><a href="#2-电缆标识示例" class="headerlink" title="(2) 电缆标识示例"></a>(2) <strong>电缆标识示例</strong></h4><ul>
<li><strong>BV</strong>：表示单股铜线，PVC绝缘电线。常用于家庭电路和一些小功率电器。</li>
<li><strong>BVV</strong>：表示单股铜线，PVC绝缘，PVC护套电线。</li>
<li><strong>RV</strong>：表示多股铜线，PVC绝缘电线，适合弯曲使用。</li>
<li><strong>RVB</strong>：表示多股铜线，PVC绝缘，PVC护套电线。</li>
<li><strong>XLPE</strong>：交联聚乙烯绝缘电缆，适用于高温环境。</li>
<li><strong>VV</strong>：铜线，PVC绝缘，PVC护套电缆，常用于一般低压电力传输。</li>
<li><strong>VV22</strong>：铜线，PVC绝缘，PVC护套，钢带铠装电缆，适用于电力传输线。</li>
</ul>
<h4 id="3-电力电缆的型号"><a href="#3-电力电缆的型号" class="headerlink" title="(3) 电力电缆的型号"></a>(3) <strong>电力电缆的型号</strong></h4><ul>
<li><strong>YJV</strong>：铜芯交联聚乙烯绝缘电力电缆，适用于低压配电系统。</li>
<li><strong>VV</strong>：铜芯PVC绝缘电力电缆，适用于普通低压电力传输。</li>
<li><strong>ZRYJV</strong>：阻燃型铜芯交联聚乙烯绝缘电力电缆，具有阻燃性能。</li>
</ul>
<h4 id="4-电缆的主要规格"><a href="#4-电缆的主要规格" class="headerlink" title="(4) 电缆的主要规格"></a>(4) <strong>电缆的主要规格</strong></h4><ul>
<li><strong>型号</strong>：电缆的类型和用途。</li>
<li><strong>规格</strong>：通常以“截面面积”表示，如：1.5mm²、2.5mm²、4mm²等，表示电缆的截面面积（或电线的直径）。</li>
<li><strong>电压等级</strong>：如0.6/1kV，表示电缆适用的最高电压。</li>
</ul>
<h4 id="4-电线的选择"><a href="#4-电线的选择" class="headerlink" title="(4) 电线的选择"></a>(4) <strong>电线的选择</strong></h4><p>选择电线时，通常需要考虑以下因素：</p>
<ul>
<li><strong>负载电流</strong>：根据电器的额定电流选择电线的规格，电线的截面面积应该能够承受负载电流。</li>
<li><strong>环境条件</strong>：选择适合的电缆材料和绝缘层（如是否防水、抗紫外线、耐高温等）。</li>
<li><strong>电压等级</strong>：确保电线的额定电压适应电力系统的要求。</li>
<li><strong>安全性</strong>：选择符合国家标准的电线，以确保使用安全。</li>
</ul>
<h3 id="4-接线方式"><a href="#4-接线方式" class="headerlink" title="4.接线方式"></a><strong>4.接线方式</strong></h3><h4 id="1-直通接线（直线接）"><a href="#1-直通接线（直线接）" class="headerlink" title="(1) 直通接线（直线接）"></a>(1) <strong>直通接线（直线接）</strong></h4><ul>
<li><p><strong>应用场景</strong>：用于简单的电路连接，如家庭用电中开关与灯具的连接。</p>
</li>
<li><p>接线方法</p>
<p>：将电线的两端分别连接到电器的输入和输出端。</p>
<ul>
<li><strong>注意事项</strong>：确保接头的绝缘层不损坏，防止短路或漏电。</li>
</ul>
</li>
</ul>
<h4 id="2-并联接线"><a href="#2-并联接线" class="headerlink" title="(2) 并联接线"></a>(2) <strong>并联接线</strong></h4><ul>
<li><p><strong>应用场景</strong>：用于多个电器设备共同使用一个电源时，如家用电器、电灯等。</p>
</li>
<li><p>接线方法</p>
<p>：将所有设备的正负端分别接到电源的正负极。</p>
<ul>
<li><strong>注意事项</strong>：每个电器的额定功率要考虑，确保总负载不超过电路设计容量。</li>
</ul>
</li>
</ul>
<h4 id="3-串联接线"><a href="#3-串联接线" class="headerlink" title="(3) 串联接线"></a>(3) <strong>串联接线</strong></h4><ul>
<li><p><strong>应用场景</strong>：不常用于家庭电路，主要用于低电流、低电压的电路连接，如电池串联。</p>
</li>
<li><p>接线方法</p>
<p>：多个电器串联连接，一个接一个地连接。</p>
<ul>
<li><strong>注意事项</strong>：每个电器的电压和电流必须匹配，否则会导致电流不均。</li>
</ul>
</li>
</ul>
<h4 id="4-接地接线"><a href="#4-接地接线" class="headerlink" title="(4) 接地接线"></a>(4) <strong>接地接线</strong></h4><ul>
<li><p><strong>应用场景</strong>：电气设备的接地保护，防止漏电对人体造成伤害。</p>
</li>
<li><p>接线方法</p>
<p>：将电气设备的接地端子通过接地线连接到大地或接地系统。</p>
<ul>
<li><strong>注意事项</strong>：接地电阻要尽量小，接地线应有足够的载流能力，避免因接地故障造成电击。</li>
</ul>
</li>
</ul>
<h3 id="2-用线的标准"><a href="#2-用线的标准" class="headerlink" title="2. 用线的标准"></a>2. <strong>用线的标准</strong></h3><p>电线的选择直接影响到电路的安全和性能。常见的标准依据有电流负载能力、电压等级、环境条件等。</p>
<h4 id="1-电流负载能力"><a href="#1-电流负载能力" class="headerlink" title="(1) 电流负载能力"></a>(1) <strong>电流负载能力</strong></h4><p>根据电流的大小选择合适的电线规格。电线的截面面积（单位：mm²）决定了它的载流能力。电流过大会导致电线过热，甚至引发火灾。</p>
<ul>
<li><p>一般家庭用电线选择参考</p>
<p>：</p>
<ul>
<li><strong>1.5mm²</strong>：用于单相电路的照明、电插座小功率电器，额定电流10A。</li>
<li><strong>2.5mm²</strong>：适用于普通插座电路和较大功率的家用电器，额定电流16A。</li>
<li><strong>4mm²</strong>：适用于空调、大功率电器，额定电流20A。</li>
<li><strong>6mm²及以上</strong>：用于大功率设备或长距离电力传输（如电焊机、空调主电源线），额定电流30A及以上。</li>
</ul>
</li>
</ul>
<h4 id="2-电压等级"><a href="#2-电压等级" class="headerlink" title="(2) 电压等级"></a>(2) <strong>电压等级</strong></h4><p>选择电线时必须确保其额定电压适应系统的工作电压。常见电压等级有：</p>
<ul>
<li><strong>低压电线</strong>（220V-380V）：家庭常用电源电线，常见额定电压0.6/1kV。</li>
<li><strong>高压电线</strong>（大于1kV）：用于配电、工业电力传输等。</li>
</ul>
<h4 id="3-环境条件"><a href="#3-环境条件" class="headerlink" title="(3) 环境条件"></a>(3) <strong>环境条件</strong></h4><ul>
<li><strong>室内电线</strong>：通常使用PVC绝缘电线，适用于干燥、温度较低的环境。</li>
<li><strong>户外电线</strong>：使用耐候性好的电线，如XLPE电缆，具有抗紫外线和耐高温的特点。</li>
<li><strong>防水电线</strong>：在潮湿环境中，需要使用防水、耐腐蚀的电线，如橡胶绝缘线。</li>
</ul>
<h4 id="4-常见电缆选择标准"><a href="#4-常见电缆选择标准" class="headerlink" title="(4) 常见电缆选择标准"></a>(4) <strong>常见电缆选择标准</strong></h4><ul>
<li><strong>BV（铜芯单股线）</strong>：常用于家庭电路和短距离电路。</li>
<li><strong>BVV（铜芯单股线，PVC绝缘护套）</strong>：用于住宅电路、建筑物内部配线。</li>
<li><strong>RV（多股铜线，PVC绝缘）</strong>：适用于需要弯曲或有一定柔性的电线。</li>
<li><strong>XLPE</strong>：交联聚乙烯绝缘电缆，适用于高温、高压环境。</li>
<li><strong>电力电缆（如YJV、VV）</strong>：用于配电网、工业电力系统中。</li>
</ul>
<h3 id="3-电器元件选择"><a href="#3-电器元件选择" class="headerlink" title="3. 电器元件选择"></a>3. <strong>电器元件选择</strong></h3><p>选择电器元件（如开关、插座、断路器等）时，必须根据电流大小、负载类型、电压等级和使用场合来决定。</p>
<h4 id="1-开关的选择"><a href="#1-开关的选择" class="headerlink" title="(1) 开关的选择"></a>(1) <strong>开关的选择</strong></h4><p>开关用于控制电流的通断。开关的选择依据主要是其额定电流和工作电压。</p>
<ul>
<li><strong>1-2.5A</strong>：用于小功率电器的开关，如照明灯具。</li>
<li><strong>10A-16A</strong>：用于普通家庭电器的开关，如插座、风扇、电视等。</li>
<li><strong>20A及以上</strong>：用于大功率电器的开关，如空调、热水器等。</li>
</ul>
<h4 id="2-插座的选择"><a href="#2-插座的选择" class="headerlink" title="(2) 插座的选择"></a>(2) <strong>插座的选择</strong></h4><p>插座用于连接电气设备的电源，选择时需要根据电流和设备的功率来确定额定值。</p>
<ul>
<li><strong>10A插座</strong>：适用于小功率电器，如电灯、电视机、电脑。</li>
<li><strong>16A插座</strong>：适用于家用大功率电器，如冰箱、空调。</li>
<li><strong>专用插座</strong>：用于专用电器，电流可达到20A及以上，如洗衣机、空调等。</li>
</ul>
<h4 id="3-断路器的选择"><a href="#3-断路器的选择" class="headerlink" title="(3) 断路器的选择"></a>(3) <strong>断路器的选择</strong></h4><p>断路器用于电路中短路、过载保护。断路器的额定电流和额定电压要根据电路的设计来选定。</p>
<ul>
<li><strong>10A</strong>：适用于小功率电路，如照明、插座电路。</li>
<li><strong>16A-20A</strong>：适用于普通家庭电器电路。</li>
<li><strong>30A及以上</strong>：适用于大功率电器或设备，如电动工具、电焊机、空调等。</li>
</ul>
<h4 id="4-熔断器的选择"><a href="#4-熔断器的选择" class="headerlink" title="(4) 熔断器的选择"></a>(4) <strong>熔断器的选择</strong></h4><p>熔断器是一种过载保护装置，当电流过大时，熔断器会熔断，切断电路，防止电路损坏。</p>
<ul>
<li><strong>3A-5A</strong>：适用于低功率电器。</li>
<li><strong>10A-20A</strong>：适用于普通家庭用电设备。</li>
<li><strong>30A及以上</strong>：适用于工业和大功率电气设备。</li>
</ul>
<h4 id="5-电气元件选型示例："><a href="#5-电气元件选型示例：" class="headerlink" title="(5) 电气元件选型示例："></a>(5) <strong>电气元件选型示例</strong>：</h4><ul>
<li><strong>1.5mm²铜线</strong> + <strong>16A断路器</strong> + <strong>16A插座</strong>：适用于家庭常规照明电路和小功率电器。</li>
<li><strong>2.5mm²铜线</strong> + <strong>20A断路器</strong> + <strong>20A插座</strong>：适用于家庭大功率电器（如空调、冰箱等）。</li>
</ul>
<h3 id="4-常见负载的电线和元件选择"><a href="#4-常见负载的电线和元件选择" class="headerlink" title="4. 常见负载的电线和元件选择"></a>4. <strong>常见负载的电线和元件选择</strong></h3><h4 id="1-照明电路"><a href="#1-照明电路" class="headerlink" title="(1) 照明电路"></a>(1) <strong>照明电路</strong></h4><ul>
<li><strong>电线</strong>：1.5mm² 铜线</li>
<li><strong>开关</strong>：10A 单极开关</li>
<li><strong>断路器</strong>：10A 断路器</li>
<li><strong>插座</strong>：10A 插座（如灯具插座）</li>
</ul>
<h4 id="2-插座电路"><a href="#2-插座电路" class="headerlink" title="(2) 插座电路"></a>(2) <strong>插座电路</strong></h4><ul>
<li><strong>电线</strong>：2.5mm² 铜线</li>
<li><strong>插座</strong>：16A 插座</li>
<li><strong>断路器</strong>：16A 断路器</li>
</ul>
<h4 id="3-空调电路"><a href="#3-空调电路" class="headerlink" title="(3) 空调电路"></a>(3) <strong>空调电路</strong></h4><ul>
<li><strong>电线</strong>：4mm² 铜线（根据空调功率选择）</li>
<li><strong>插座</strong>：20A 插座</li>
<li><strong>断路器</strong>：20A 断路器</li>
</ul>
<h4 id="4-厨房用电（如电热水器、电磁炉）"><a href="#4-厨房用电（如电热水器、电磁炉）" class="headerlink" title="(4) 厨房用电（如电热水器、电磁炉）"></a>(4) <strong>厨房用电（如电热水器、电磁炉）</strong></h4><ul>
<li><strong>电线</strong>：4mm² 或 6mm² 铜线（根据电器功率）</li>
<li><strong>插座</strong>：20A 插座</li>
<li><strong>断路器</strong>：20A 或 25A 断路器</li>
</ul>
<h2 id="5-电工接线基础知识"><a href="#5-电工接线基础知识" class="headerlink" title="5.电工接线基础知识"></a>5.电工接线基础知识</h2><h3 id="1-电线的种类与规格"><a href="#1-电线的种类与规格" class="headerlink" title="1. 电线的种类与规格"></a>1. <strong>电线的种类与规格</strong></h3><p>电工中常用的电线种类及其应用场景如下：</p>
<ul>
<li><strong>BV线</strong>：单股硬铜线，常用于电气布线。</li>
<li><strong>RV线</strong>：多股软铜线，适用于可弯曲的电路。</li>
<li><strong>VV线</strong>：铜芯PVC绝缘电力电缆，用于室内固定布线。</li>
<li><strong>XLPE电缆</strong>：交联聚乙烯电缆，适用于高温和严苛环境。</li>
<li><strong>橡胶线</strong>：适用于潮湿环境和户外电气设备。</li>
</ul>
<p><strong>选择标准</strong>：</p>
<ul>
<li>电流负载能力：例如，1.5mm²铜线适用于10A以下的小功率电器，2.5mm²适用于家用电器，4mm²适用于空调等大功率电器。</li>
<li>电压等级：低压电线一般使用0.6/1kV级别的电缆。</li>
</ul>
<hr>
<h3 id="2-四根电线的功能和接法"><a href="#2-四根电线的功能和接法" class="headerlink" title="2. 四根电线的功能和接法"></a>2. <strong>四根电线的功能和接法</strong></h3><p>通常，家用电气设备中会使用四根电线，它们分别是：</p>
<ul>
<li><strong>L线（火线）</strong>：通常为红色或黑色，带电，负责输送电流到负载设备。</li>
<li><strong>N线（零线）</strong>：通常为蓝色，电路的返回路径，不带电，闭合回路。</li>
<li><strong>PE线（保护地线）</strong>：通常为黄绿相间，接地线，用于安全接地，防止漏电。</li>
<li><strong>中性线（地线）</strong>：在某些特定电器和工业电气系统中，可能会用到专门的中性线来保持电压平衡。</li>
</ul>
<h4 id="家庭接线的基本规则："><a href="#家庭接线的基本规则：" class="headerlink" title="家庭接线的基本规则："></a>家庭接线的基本规则：</h4><ol>
<li><strong>火线与零线</strong>连接到电器的输入端，火线带电，零线回流。</li>
<li><strong>接地线</strong>必须接到电器的接地端，防止因漏电造成触电危险。</li>
</ol>
<h4 id="接线方式："><a href="#接线方式：" class="headerlink" title="接线方式："></a>接线方式：</h4><ul>
<li><strong>单相电接线</strong>：一般家庭电器，如灯光、插座等，采用单相电220V的方式。火线接到电器一端，零线接电器另一端，接地线接到接地端。</li>
<li><strong>三相电接线</strong>：用于大功率电器（如空调、电动工具），三相电系统有三个火线，电流分流传输，可以实现更大功率的电力传输。通常还会接地线。</li>
</ul>
<h4 id="火线、零线、接地线的正确接法："><a href="#火线、零线、接地线的正确接法：" class="headerlink" title="火线、零线、接地线的正确接法："></a><strong>火线、零线、接地线的正确接法</strong>：</h4><ul>
<li><strong>火线（L）</strong>：接入电器的正极。</li>
<li><strong>零线（N）</strong>：接入电器的负极，回流电流。</li>
<li><strong>接地线（PE）</strong>：连接电器外壳或电气设备的接地端，起到安全保护作用。</li>
</ul>
<h4 id="四线电源接线图："><a href="#四线电源接线图：" class="headerlink" title="四线电源接线图："></a><strong>四线电源接线图</strong>：</h4><p>在家庭电路中，接线一般如下所示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext复制代码       电源  --&gt; 火线（L） --&gt; 电器</span><br><span class="line">                   |</span><br><span class="line">                   --&gt; 零线（N） --&gt; 电器</span><br><span class="line">                   |</span><br><span class="line">                   --&gt; 接地线（PE） --&gt; 电器接地端</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="3-常见电器元件及其选型"><a href="#3-常见电器元件及其选型" class="headerlink" title="3. 常见电器元件及其选型"></a>3. <strong>常见电器元件及其选型</strong></h3><p>根据用电设备的功率和电流，选择适合的电器元件（如开关、插座、断路器、熔断器等）来保证电气安全。</p>
<h4 id="1-开关："><a href="#1-开关：" class="headerlink" title="(1) 开关："></a>(1) <strong>开关</strong>：</h4><ul>
<li><strong>10A单极开关</strong>：适用于小功率电器，如灯具、风扇。</li>
<li><strong>16A双极开关</strong>：适用于电力需求较大的电器，如电热水器、空调。</li>
<li><strong>20A以上开关</strong>：适用于工业设备或大功率电器。</li>
</ul>
<h4 id="2-插座："><a href="#2-插座：" class="headerlink" title="(2) 插座："></a>(2) <strong>插座</strong>：</h4><ul>
<li><strong>10A插座</strong>：适用于常规电器，如台灯、电脑、电视等。</li>
<li><strong>16A插座</strong>：适用于空调、冰箱等家用电器。</li>
<li><strong>20A插座</strong>：适用于电动工具、大功率家电或工业用电。</li>
</ul>
<h4 id="3-断路器："><a href="#3-断路器：" class="headerlink" title="(3) 断路器："></a>(3) <strong>断路器</strong>：</h4><ul>
<li><strong>10A断路器</strong>：适用于家用电器电路。</li>
<li><strong>16A断路器</strong>：适用于普通家庭用电电路。</li>
<li><strong>30A及以上断路器</strong>：适用于大功率电器、工业电路。</li>
</ul>
<h4 id="4-熔断器："><a href="#4-熔断器：" class="headerlink" title="(4) 熔断器："></a>(4) <strong>熔断器</strong>：</h4><ul>
<li><strong>3A-5A熔断器</strong>：适用于低功率电器。</li>
<li><strong>10A-20A熔断器</strong>：适用于家庭电路和常见家电。</li>
<li><strong>30A及以上熔断器</strong>：适用于工业电气设备，提供过载保护。</li>
</ul>
<hr>
<h3 id="4-电气系统中的接线方式和接地方式"><a href="#4-电气系统中的接线方式和接地方式" class="headerlink" title="4. 电气系统中的接线方式和接地方式"></a>4. <strong>电气系统中的接线方式和接地方式</strong></h3><h4 id="1-单相电接线："><a href="#1-单相电接线：" class="headerlink" title="(1) 单相电接线："></a>(1) <strong>单相电接线</strong>：</h4><ul>
<li><strong>火线</strong>：带电线，用于供电。</li>
<li><strong>零线</strong>：不带电的回流路径。</li>
<li><strong>接地线</strong>：用于接地保护。</li>
</ul>
<p><strong>接法</strong>：</p>
<ul>
<li>电源的火线和零线分别接到电器的输入端。</li>
<li>接地线接到电器的外壳或地线端子，防止漏电危险。</li>
</ul>
<h4 id="2-三相电接线："><a href="#2-三相电接线：" class="headerlink" title="(2) 三相电接线："></a>(2) <strong>三相电接线</strong>：</h4><p>三相电用于更大功率的电器和工业设备，通常由三根火线（L1, L2, L3）和一根零线（N）组成。每根火线之间的电压为400V，而火线与零线之间的电压为220V。此类电路常见于空调、大型工业设备等。</p>
<p><strong>接法</strong>：</p>
<ul>
<li>三根火线连接到电器的输入端（通常是大型电动机或工业设备）。</li>
<li>零线接电器的回流端，保证电流闭合。</li>
<li>接地线用于电气设备的安全保护。</li>
</ul>
<h4 id="3-地线与中性线："><a href="#3-地线与中性线：" class="headerlink" title="(3) 地线与中性线："></a>(3) <strong>地线与中性线</strong>：</h4><ul>
<li><strong>中性线（N）</strong>：电流回流通道，与火线电压相差零，起到平衡作用。用于低压供电。</li>
<li><strong>接地线（PE）</strong>：用于将电气设备的金属外壳接地，防止触电。</li>
</ul>
<hr>
<h3 id="5-常见电路的电线选择标准"><a href="#5-常见电路的电线选择标准" class="headerlink" title="5. 常见电路的电线选择标准"></a>5. <strong>常见电路的电线选择标准</strong></h3><p>以下是常见电器电路的电线选择标准：</p>
<h4 id="1-照明电路："><a href="#1-照明电路：" class="headerlink" title="(1) 照明电路："></a>(1) <strong>照明电路</strong>：</h4><ul>
<li><strong>电线规格</strong>：1.5mm²铜线（适用于家庭照明）</li>
<li><strong>电器选择</strong>：普通开关、10A断路器。</li>
</ul>
<h4 id="2-插座电路："><a href="#2-插座电路：" class="headerlink" title="(2) 插座电路："></a>(2) <strong>插座电路</strong>：</h4><ul>
<li><strong>电线规格</strong>：2.5mm²铜线（适用于家庭插座）</li>
<li><strong>电器选择</strong>：16A插座、16A断路器。</li>
</ul>
<h4 id="3-空调电路："><a href="#3-空调电路：" class="headerlink" title="(3) 空调电路："></a>(3) <strong>空调电路</strong>：</h4><ul>
<li><strong>电线规格</strong>：4mm²或6mm²铜线（适用于空调大功率设备）</li>
<li><strong>电器选择</strong>：20A插座、20A断路器。</li>
</ul>
<h4 id="4-厨房用电（电热水器、电炉等）："><a href="#4-厨房用电（电热水器、电炉等）：" class="headerlink" title="(4) 厨房用电（电热水器、电炉等）："></a>(4) <strong>厨房用电（电热水器、电炉等）</strong>：</h4><ul>
<li><strong>电线规格</strong>：4mm²或6mm²铜线（大功率电器）</li>
<li><strong>电器选择</strong>：20A插座、20A断路器。</li>
</ul>
<h4 id="5-电动工具或工业设备电路："><a href="#5-电动工具或工业设备电路：" class="headerlink" title="(5) 电动工具或工业设备电路："></a>(5) <strong>电动工具或工业设备电路</strong>：</h4><ul>
<li><strong>电线规格</strong>：10mm²及以上铜线（大功率设备）</li>
<li><strong>电器选择</strong>：30A断路器、20A插座。</li>
</ul>
<hr>
<h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. <strong>注意事项</strong></h3><ul>
<li><strong>确保接地</strong>：所有带金属外壳的电器设备都必须接地，避免漏电时发生电击。</li>
<li><strong>避免过载</strong>：不要将电器设备接入超出电线额定负载的电路。</li>
<li><strong>检查电缆规格</strong>：根据电流、功率需求选择合适的电缆规格，避免电缆过热引发火灾。</li>
<li><strong>保护措施</strong>：确保所有电气系统配备适当的断路器、熔断器等过载保护设备。</li>
</ul>
<h2 id="6-1万能表的基本结构"><a href="#6-1万能表的基本结构" class="headerlink" title="6.1万能表的基本结构"></a>6.1万能表的基本结构</h2><h3 id="1-表头（显示屏）"><a href="#1-表头（显示屏）" class="headerlink" title="1. 表头（显示屏）"></a>1. <strong>表头（显示屏）</strong></h3><ul>
<li>显示屏用于显示测量结果，通常为LCD屏，显示数字和单位。</li>
</ul>
<h3 id="2-旋转开关（功能选择开关）"><a href="#2-旋转开关（功能选择开关）" class="headerlink" title="2. 旋转开关（功能选择开关）"></a>2. <strong>旋转开关（功能选择开关）</strong></h3><ul>
<li>旋转开关通常位于万用表的中间，用于选择测量功能（如电压、电流、电阻等）。</li>
</ul>
<h3 id="3-测试探头"><a href="#3-测试探头" class="headerlink" title="3. 测试探头"></a>3. <strong>测试探头</strong></h3><ul>
<li>万用表配有两个探头，红色为正极（通常连接到表的V、A、Ω端），黑色为负极（连接到COM端）。</li>
</ul>
<h3 id="4-端子"><a href="#4-端子" class="headerlink" title="4. 端子"></a>4. <strong>端子</strong></h3><ul>
<li><strong>COM端</strong>：通常是黑色探头连接的地方，是公共端，通常与负极接通。</li>
<li><strong>V/Ω端</strong>：通常用于测量电压、电阻、电容等参数。</li>
<li><strong>A端</strong>：通常用于测量电流。</li>
</ul>
<hr>
<h2 id="6-2功能"><a href="#6-2功能" class="headerlink" title="6.2功能"></a>6.2功能</h2><h3 id="1-表头（显示屏）-1"><a href="#1-表头（显示屏）-1" class="headerlink" title="1. 表头（显示屏）"></a>1. <strong>表头（显示屏）</strong></h3><ul>
<li>显示屏用于显示测量结果，通常为LCD屏，显示数字和单位。</li>
</ul>
<h3 id="2-旋转开关（功能选择开关）-1"><a href="#2-旋转开关（功能选择开关）-1" class="headerlink" title="2. 旋转开关（功能选择开关）"></a>2. <strong>旋转开关（功能选择开关）</strong></h3><ul>
<li>旋转开关通常位于万用表的中间，用于选择测量功能（如电压、电流、电阻等）。</li>
</ul>
<h3 id="3-测试探头-1"><a href="#3-测试探头-1" class="headerlink" title="3. 测试探头"></a>3. <strong>测试探头</strong></h3><ul>
<li>万用表配有两个探头，红色为正极（通常连接到表的V、A、Ω端），黑色为负极（连接到COM端）。</li>
</ul>
<h3 id="4-端子-1"><a href="#4-端子-1" class="headerlink" title="4. 端子"></a>4. <strong>端子</strong></h3><ul>
<li><strong>COM端</strong>：通常是黑色探头连接的地方，是公共端，通常与负极接通。</li>
<li><strong>V/Ω端</strong>：通常用于测量电压、电阻、电容等参数。</li>
<li><strong>A端</strong>：通常用于测量电流。</li>
</ul>
<h3 id="1-测量直流电压（DC-Voltage，DCV）"><a href="#1-测量直流电压（DC-Voltage，DCV）" class="headerlink" title="1. 测量直流电压（DC Voltage，DCV）"></a>1. <strong>测量直流电压（DC Voltage，DCV）</strong></h3><ul>
<li><p><strong>功能选择</strong>：将旋转开关调到带有“DCV”或直流电压的标志。通常是一个V字形符号，下方有一条实线和虚线。</p>
</li>
<li><p><strong>用途</strong>：测量直流电压（如电池、直流电源等）。</p>
</li>
<li><p>操作步骤</p>
<p>：</p>
<ol>
<li>将黑色探头插入COM端，红色探头插入V/Ω端。</li>
<li>将探头分别接触电路的负极（黑色探头）和正极（红色探头）。</li>
<li>读取显示屏上的电压值，单位是伏特（V）。</li>
</ol>
<p>注意</p>
<p>：在测量直流电压时，确保万用表的红色探头连接到电路的正极，黑色探头连接到负极。</p>
</li>
</ul>
<hr>
<h3 id="2-测量交流电压（AC-Voltage，ACV）"><a href="#2-测量交流电压（AC-Voltage，ACV）" class="headerlink" title="2. 测量交流电压（AC Voltage，ACV）"></a>2. <strong>测量交流电压（AC Voltage，ACV）</strong></h3><ul>
<li><p><strong>功能选择</strong>：将旋转开关调到带有“ACV”或交流电压的标志。通常是一个V字形符号，上面没有实线或虚线。</p>
</li>
<li><p><strong>用途</strong>：测量交流电压（如家用电源、工业电源等）。</p>
</li>
<li><p>操作步骤</p>
<p>：</p>
<ol>
<li>将黑色探头插入COM端，红色探头插入V/Ω端。</li>
<li>将探头分别接触电路的任意两个点（可以不区分正负极）。</li>
<li>读取显示屏上的电压值，单位是伏特（V）。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="3-测量直流电流（DC-Current，DCA）"><a href="#3-测量直流电流（DC-Current，DCA）" class="headerlink" title="3. 测量直流电流（DC Current，DCA）"></a>3. <strong>测量直流电流（DC Current，DCA）</strong></h3><ul>
<li><p><strong>功能选择</strong>：将旋转开关调到“DCA”位置，通常有字母“A”和一个直流符号（-）标志。</p>
</li>
<li><p><strong>用途</strong>：测量直流电流（如电池供电的设备、电动工具等）。</p>
</li>
<li><p>操作步骤</p>
<p>：</p>
<ol>
<li>将黑色探头插入COM端，红色探头插入A端（注意：通常电流档需要插入不同的端子）。</li>
<li>将万用表串联到电路中，也就是说电流必须通过万用表。</li>
<li>读取显示屏上的电流值，单位是安培（A）。</li>
</ol>
<p>注意</p>
<p>：测量电流时一定要断开电路，万用表串联在电路中进行测量。</p>
</li>
</ul>
<hr>
<h3 id="4-测量交流电流（AC-Current，ACA）"><a href="#4-测量交流电流（AC-Current，ACA）" class="headerlink" title="4. 测量交流电流（AC Current，ACA）"></a>4. <strong>测量交流电流（AC Current，ACA）</strong></h3><ul>
<li><p><strong>功能选择</strong>：将旋转开关调到“ACA”位置，通常有字母“A”和交流符号（~）标志。</p>
</li>
<li><p><strong>用途</strong>：测量交流电流（如家用电器、电动工具等）。</p>
</li>
<li><p>操作步骤</p>
<p>：</p>
<ol>
<li>将黑色探头插入COM端，红色探头插入A端（与直流电流测量相同）。</li>
<li>将万用表串联到电路中，测量电流通过万用表。</li>
<li>读取显示屏上的电流值，单位是安培（A）。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="5-测量电阻（Resistance，Ω）"><a href="#5-测量电阻（Resistance，Ω）" class="headerlink" title="5. 测量电阻（Resistance，Ω）"></a>5. <strong>测量电阻（Resistance，Ω）</strong></h3><ul>
<li><p><strong>功能选择</strong>：将旋转开关调到电阻档（Ω标志）。</p>
</li>
<li><p><strong>用途</strong>：测量电路的电阻（如电线、电阻器等元件的电阻）。</p>
</li>
<li><p><strong>操作步骤</strong>：</p>
<ol>
<li>将黑色探头插入COM端，红色探头插入V/Ω端。</li>
<li>将探头接触待测元件的两端。</li>
<li>读取显示屏上的电阻值，单位是欧姆（Ω）。</li>
</ol>
<p><strong>注意</strong>：在测量电阻时，必须确保电路是断电的，不能在通电状态下测量电阻。</p>
</li>
</ul>
<hr>
<h3 id="6-测量二极管（Diode-Test）"><a href="#6-测量二极管（Diode-Test）" class="headerlink" title="6. 测量二极管（Diode Test）"></a>6. <strong>测量二极管（Diode Test）</strong></h3><ul>
<li><p><strong>功能选择</strong>：将旋转开关调到二极管测试档，通常是一个二极管的符号（箭头与线段符号）。</p>
</li>
<li><p><strong>用途</strong>：检查二极管的正向压降和反向阻断特性。</p>
</li>
<li><p>操作步骤</p>
<p>：</p>
<ol>
<li>将黑色探头插入COM端，红色探头插入V/Ω端。</li>
<li>将探头接触二极管的两个端子，红色探头接正极，黑色探头接负极。</li>
<li>读取显示屏上的电压值，通常二极管的正向压降在0.6V~0.7V之间。</li>
</ol>
<p>注意</p>
<p>：如果显示为“OL”或无任何显示，表示二极管已经损坏，或者存在短路。</p>
</li>
</ul>
<hr>
<h3 id="7-测量电容（Capacitance，Cap）"><a href="#7-测量电容（Capacitance，Cap）" class="headerlink" title="7. 测量电容（Capacitance，Cap）"></a>7. <strong>测量电容（Capacitance，Cap）</strong></h3><ul>
<li><p><strong>功能选择</strong>：将旋转开关调到电容档（标有“Cap”或电容符号）。</p>
</li>
<li><p><strong>用途</strong>：测量电容器的电容值。</p>
</li>
<li><p>操作步骤</p>
<p>：</p>
<ol>
<li>将黑色探头插入COM端，红色探头插入V/Ω端。</li>
<li>将探头接触电容的两个引脚。</li>
<li>读取显示屏上的电容值，单位是法拉（F），常见单位还有微法（μF）、皮法（pF）等。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="8-测量频率（Frequency）"><a href="#8-测量频率（Frequency）" class="headerlink" title="8. 测量频率（Frequency）"></a>8. <strong>测量频率（Frequency）</strong></h3><ul>
<li><p><strong>功能选择</strong>：将旋转开关调到频率档，通常标有“Hz”。</p>
</li>
<li><p><strong>用途</strong>：测量信号的频率，常用于测试交流电的频率或信号源的频率。</p>
</li>
<li><p>操作步骤</p>
<p>：</p>
<ol>
<li>将黑色探头插入COM端，红色探头插入V/Ω端。</li>
<li>将探头接触待测信号源的两端。</li>
<li>读取显示屏上的频率值，单位是赫兹（Hz）。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="9-测量温度（Temperature）"><a href="#9-测量温度（Temperature）" class="headerlink" title="9. 测量温度（Temperature）"></a>9. <strong>测量温度（Temperature）</strong></h3><ul>
<li><p><strong>功能选择</strong>：将旋转开关调到温度档，通常标有一个温度符号（℃ 或 ℉）。</p>
</li>
<li><p><strong>用途</strong>：测量物体的温度（如电气元件的温度、环境温度等）。</p>
</li>
<li><p>操作步骤</p>
<p>：</p>
<ol>
<li>插入温度探头，通常温度探头有两种插孔：一种是插在V/Ω端，另一种是插在专用温度端口。</li>
<li>将探头接触待测物体，读取显示的温度值，单位为℃或℉。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>电气</category>
      </categories>
      <tags>
        <tag>电气</tag>
      </tags>
  </entry>
  <entry>
    <title>cad笔记</title>
    <url>/2024/11/19/cad%E7%AC%94%E8%AE%B0%20copy/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!-- 
    <div id="aplayer-gHdBfFrn" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="3986040" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"
    ></div> -->

<!-- 
    <div id="aplayer-zInzwlkL" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="2496552067" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"
    ></div> -->



<h4 id="线条指令"><a href="#线条指令" class="headerlink" title="线条指令"></a>线条指令</h4><p>L直线指令 PL多段线指令，ML多线指令，SPL样条曲线，(以上指令共同功能:输入C关闭，可以闭合线段头尾，形成闭合区)</p>
<h4 id="正交模式"><a href="#正交模式" class="headerlink" title="正交模式"></a>正交模式</h4><p>F8正交模式(按住shift键为临时开关)限制光标的编辑方向为水平/垂直的轴向</p>
<h4 id="极轴追踪"><a href="#极轴追踪" class="headerlink" title="极轴追踪"></a>极轴追踪</h4><p>F10极轴追踪，从上一个点/基点延伸出虚线，与光标进行对齐和追踪操作虚线方向可以进行设置(SE)</p>
<h4 id="增量角"><a href="#增量角" class="headerlink" title="增量角"></a>增量角</h4><p>增量角:为每根虚线之间的夹角</p>
<p>附加角:单独设置的角度线条(极轴角度)</p>
<h4 id="角度替代"><a href="#角度替代" class="headerlink" title="角度替代"></a>角度替代</h4><p>角度替代在指令中定点定位需要一个角度方向时，输入〈角度值进行编辑方向限制<br>角度符号;’’小于号,逗号键大写，注意关闭中文输入法，否则为书名号《</p>
<h4 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h4><p><strong>快速标注-QDIM</strong></p>
<p>CAD快速标注快捷键命令为：QDIM，主要用于从选定对象中快速创建一组标注。</p>
<p><strong>线性标注-DLI</strong></p>
<p>CAD线性标注命令为：DIMLINEAR，快捷键：DLI；主要用于创建线性标注。</p>
<p><strong>对齐标注-DAL</strong></p>
<p>CAD对齐标注命令为：DIMALIGNED，快捷键：DAL；主要用于创建对齐线性标注。</p>
<p><strong>半径标注-DRA</strong></p>
<p>CAD半径标注命令为：DIMRADIUS，快捷键：DRA；主要用于创建圆或圆弧的半径标注。</p>
<p><strong>直径标注-DDI</strong></p>
<p>CAD直径标注命令为：DIMDIAMETER，快捷键：DDI；主要用于创建圆、圆弧的直径标注，可将直径线以任何角度放在圆或圆弧的内外。</p>
<p><strong>角度标注-DAN</strong></p>
<p>CAD角度标注命令为：DIMANGULAR，快捷键：DAN；主要用于创建角度标注。</p>
<p><strong>圆心标注-DCE</strong></p>
<p>CAD圆心标注命令为：DIMCENTER，快捷键：DCE；主要用于创建圆和圆弧的圆心标记或中心线。</p>
<p><strong>坐标标注-DOR</strong></p>
<p>CAD坐标标注命令为：DIMORDINATE，快捷键：DOR；主要用于创建坐标标注。</p>
<p><strong>弧长标注-DAR</strong></p>
<p>CAD弧长标注命令为：DIMARC，快捷键：DAR；主要用于创建弧长标注。</p>
<p><strong>半径折弯标注-DJO</strong></p>
<p>CAD半径折弯标注命令为：DIMJOGGED，快捷键：DJO；主要用于对半径较大的圆或圆弧创建折弯标注。如果圆或圆弧的圆心在当前布局中无法显示到实际位置，用户可以使用折弯标注，可以将替代圆心放到一个合适的位置。 </p>
<p><strong>快速引出标注-LE</strong></p>
<p>CAD快速引出标注命令为：QLEADER，快捷键：LE；主要用于创建引线和引线注释。</p>
<p><strong>基线标注-DBA</strong></p>
<p>CAD基线标注命令为：DIMBASELINE，快捷键：DBA；主要用于连接上一个标注，以继续建立线性、角度或坐标标注。若先前未建立标注，则会出现提示请您选取线性、坐标或角度标注作为基准标注。程序将基准标注的第一条延伸线作为下一个标注的第一条延伸线。</p>
<p><strong>连续标注-DCO</strong></p>
<p>CAD连续标注命令为：DIMCONTINUE，快捷键：DCO；主要用于连续标注。程序会将上个标注的第二条尺寸界线作为创建连续标注的起点。</p>
<p><strong>标注样式-D</strong></p>
<p>CAD标注样式命令为：DIMSTYLE，快捷键：D；执行命令后将显示【标注样式管理器】对话框，主要用于创建和修改标注样式。</p>
<p><strong>编辑标注-DED</strong></p>
<p>CAD编辑标注命令为：DIMEDIT，快捷键：DED；主要用于编辑标注文字和延伸线。</p>
<p><strong>替换标注系统变量-DOV</strong></p>
<p>CAD替换标注系统变量命令为：DIMOVERRIDE，快捷键：DOV；主要用于控制对选定标注中所使用的系统变量的替代。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a><strong>基本操作</strong></h4><ul>
<li><strong>Ctrl + N</strong>：新建图形</li>
<li><strong>Ctrl + O</strong>：打开图形</li>
<li><strong>Ctrl + S</strong>：保存图形</li>
<li><strong>Ctrl + P</strong>：打印</li>
<li><strong>Ctrl + C</strong>：复制</li>
<li><strong>Ctrl + V</strong>：粘贴</li>
<li><strong>Ctrl + X</strong>：剪切</li>
<li><strong>Ctrl + Z</strong>：撤销</li>
<li><strong>Ctrl + Y</strong>：重做</li>
<li><strong>Ctrl + A</strong>：全选</li>
<li><strong>Ctrl + F</strong>：查找</li>
<li><strong>Ctrl + Shift + S</strong>：另存为</li>
<li><strong>Esc</strong>：退出命令或取消选择</li>
<li><strong>Shift + Esc</strong>：取消当前命令</li>
<li><strong>Enter</strong>：确认命令</li>
<li><strong>Spacebar</strong>：重复上次命令</li>
<li><strong>F2</strong>：打开文本窗口（命令历史）</li>
<li><strong>F3</strong>：启用/禁用对象捕捉（OSNAP）</li>
<li><strong>F8</strong>：启用/禁用正交模式（ORTHO）</li>
<li><strong>F9</strong>：启用/禁用捕捉（Snap）</li>
<li><strong>F10</strong>：启用/禁用极轴约束（Polar Tracking）</li>
<li><strong>F11</strong>：启用/禁用极坐标输入（Polar Snap）</li>
<li><strong>F12</strong>：启用/禁用动态输入（Dynamic Input）</li>
</ul>
<h4 id="绘图命令"><a href="#绘图命令" class="headerlink" title="绘图命令"></a><strong>绘图命令</strong></h4><ul>
<li><strong>L</strong>：画直线（Line）</li>
<li><strong>C</strong>：画圆（Circle）</li>
<li><strong>REC</strong>：画矩形（Rectangle）</li>
<li><strong>A</strong>：画弧（Arc）</li>
<li><strong>PL</strong>：画多段线（Polyline）</li>
<li><strong>SPL</strong>：画样条曲线（Spline）</li>
<li><strong>H</strong>：填充区域（Hatch）</li>
<li><strong>M</strong>：移动（Move）</li>
<li><strong>CO</strong>：复制（Copy）</li>
<li><strong>RO</strong>：旋转（Rotate）</li>
<li><strong>SC</strong>：缩放（Scale）</li>
<li><strong>TR</strong>：修剪（Trim）</li>
<li><strong>EX</strong>：延伸（Extend）</li>
<li><strong>F</strong>：镜像（Mirror）</li>
<li><strong>S</strong>：偏移（Offset）</li>
<li><strong>B</strong>：拉伸（Stretch）</li>
<li><strong>I</strong>：插入块（Insert Block）</li>
<li><strong>X</strong>：爆炸（Explode）</li>
<li><strong>P</strong>：多边形（Polygon）</li>
<li><strong>RE</strong>：阵列（Array）</li>
<li><strong>LTS</strong>：线型比例（LineType Scale）</li>
<li><strong>BEND</strong>：弯曲（Bend）</li>
<li><strong>ALIGN</strong>：对齐（Align）</li>
<li><strong>CHPROP</strong>：更改属性（Change Properties）</li>
</ul>
<h4 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a><strong>编辑命令</strong></h4><ul>
<li><strong>D</strong>：尺寸标注（Dimension）</li>
<li><strong>ST</strong>：设置线型（Line Type）</li>
<li><strong>LA</strong>：图层管理（Layer）</li>
<li><strong>M2P</strong>：两个点之间的中点（Midpoint between two points）</li>
<li><strong>MOVE</strong>：移动（Move）</li>
<li><strong>ROTATE</strong>：旋转（Rotate）</li>
<li><strong>SCALE</strong>：缩放（Scale）</li>
<li><strong>OFFSET</strong>：偏移（Offset）</li>
<li><strong>TRIM</strong>：修剪（Trim）</li>
<li><strong>EXTEND</strong>：延伸（Extend）</li>
<li><strong>EXPLODE</strong>：爆炸（Explode）</li>
<li><strong>ARRAY</strong>：阵列（Array）</li>
<li><strong>STRETCH</strong>：拉伸（Stretch）</li>
<li><strong>MIRROR</strong>：镜像（Mirror）</li>
<li><strong>FILLET</strong>：圆角（Fillet）</li>
<li><strong>CHAMFER</strong>：倒角（Chamfer）</li>
<li><strong>BREAK</strong>：断开（Break）</li>
<li><strong>DIVIDE</strong>：分段（Divide）</li>
<li><strong>MEASURE</strong>：标距（Measure）</li>
<li><strong>MATCHPROP</strong>：匹配属性（Match Properties）</li>
<li><strong>HATCHEDIT</strong>：编辑填充区域（Hatch Edit）</li>
</ul>
<h4 id="视图和显示"><a href="#视图和显示" class="headerlink" title="视图和显示"></a><strong>视图和显示</strong></h4><ul>
<li><p>ZOOM</p>
<p>：缩放（Zoom）</p>
<ul>
<li><strong>ZE</strong>：适应所有对象</li>
<li><strong>ZW</strong>：缩放窗口</li>
<li><strong>ZA</strong>：适应所有图形</li>
<li><strong>ZP</strong>：缩放到选定对象</li>
<li>**Z+**：放大</li>
<li>**Z-**：缩小</li>
</ul>
</li>
<li><p><strong>PAN</strong>：平移（Pan）</p>
</li>
<li><p><strong>V</strong>：旋转视图（View）</p>
</li>
<li><p><strong>VSCURRENT</strong>：视图切换（Current View）</p>
</li>
<li><p><strong>PLAN</strong>：平面视图（Plan View）</p>
</li>
<li><p><strong>ISOPLANE</strong>：等角视图（Isoplane）</p>
</li>
<li><p><strong>REGEN</strong>：重生成视图（Regenerate View）</p>
</li>
</ul>
<h4 id="图层操作"><a href="#图层操作" class="headerlink" title="图层操作"></a><strong>图层操作</strong></h4><ul>
<li><strong>LA</strong>：打开图层管理器（Layer Properties Manager）</li>
<li><strong>LAYER</strong>：管理图层（Layer）</li>
<li><strong>LAYON</strong>：打开所有图层（Turn on Layers）</li>
<li><strong>LAYOFF</strong>：关闭所有图层（Turn off Layers）</li>
<li><strong>LAYISO</strong>：隔离图层（Layer Isolate）</li>
<li><strong>LAYFRZ</strong>：冻结图层（Layer Freeze）</li>
<li><strong>LAYTHW</strong>：图层透明度（Layer Transparency）</li>
</ul>
<h4 id="块与插入"><a href="#块与插入" class="headerlink" title="块与插入"></a><strong>块与插入</strong></h4><ul>
<li><strong>B</strong>：块定义（Block）</li>
<li><strong>I</strong>：插入块（Insert Block）</li>
<li><strong>WBLOCK</strong>：写入块（Write Block）</li>
<li><strong>BEDIT</strong>：编辑块定义（Block Editor）</li>
<li><strong>ATTEDIT</strong>：编辑块属性（Edit Block Attribute）</li>
<li><strong>ATTDEF</strong>：定义块属性（Block Attribute Definition）</li>
</ul>
<h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a><strong>其他常用命令</strong></h4><ul>
<li><strong>UNDO</strong>：撤销（Undo）</li>
<li><strong>REDO</strong>：重做（Redo）</li>
<li><strong>SELECT</strong>：选择对象（Select）</li>
<li><strong>GROUP</strong>：分组（Group）</li>
<li><strong>EXPLODE</strong>：爆炸（Explode）</li>
<li><strong>DIST</strong>：测量两点间距离（Distance）</li>
<li><strong>AREA</strong>：计算区域面积（Area）</li>
<li><strong>LIST</strong>：列出对象属性（List）</li>
<li><strong>SELECTALL</strong>：全选（Select All）</li>
<li><strong>RENAME</strong>：重命名对象（Rename）</li>
<li><strong>XREF</strong>：外部参照（External Reference）</li>
<li><strong>M2P</strong>：中点对齐（Midpoint）</li>
</ul>
<h4 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a><strong>辅助功能</strong></h4><ul>
<li><strong>Ctrl + 1</strong>：打开属性面板（Properties）</li>
<li><strong>Ctrl + 2</strong>：块定义管理器（Block Definition Manager）</li>
<li><strong>Ctrl + 3</strong>：工具集管理器（Tool Palette）</li>
<li><strong>Ctrl + 4</strong>：显示文件查找（DesignCenter）</li>
<li><strong>Ctrl + 5</strong>：显示检查器（Sheet Set Manager）</li>
<li><strong>Ctrl + 6</strong>：显示工具栏（Toolbar）</li>
<li><strong>Ctrl + 7</strong>：显示工具面板（Tool Palettes）</li>
<li><strong>Ctrl + 8</strong>：显示选择窗口（Quick Access Toolbar）</li>
</ul>
<h4 id="视图窗口控制"><a href="#视图窗口控制" class="headerlink" title="视图窗口控制"></a><strong>视图窗口控制</strong></h4><ul>
<li><strong>Ctrl + Shift + E</strong>：设置当前视图（Set View）</li>
<li><strong>Ctrl + Shift + C</strong>：复制视图（Copy View）</li>
<li><strong>Ctrl + Shift + V</strong>：粘贴视图（Paste View）</li>
<li><strong>Ctrl + Shift + P</strong>：打印视图（Plot View）</li>
</ul>
]]></content>
      <categories>
        <category>cad</category>
      </categories>
      <tags>
        <tag>cad</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题总结</title>
    <url>/2023/06/26/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>JavaScript，ES6知识点总结</p>
<h1 id="JavaScript-amp-amp-ES6"><a href="#JavaScript-amp-amp-ES6" class="headerlink" title="JavaScript&&ES6"></a>JavaScript&amp;&amp;ES6</h1><h3 id="js的数据类型及其存储方式"><a href="#js的数据类型及其存储方式" class="headerlink" title="js的数据类型及其存储方式"></a>js的数据类型及其存储方式</h3><ul>
<li><p><strong>基本数据类型</strong>：Number，String，Boolean，Null，Undefined，Symbol</p>
</li>
<li><p><strong>引用数据类型</strong>：Object，Array，Function，Date等等…                                                                                                             </p>
</li>
<li><p><strong>存储方式</strong>：基本数据类型存储的是值，存在栈中，数据无法修改,可以比较(比较的是值)。引用类型存储的引用，存在堆中，数据可以修改，不能比较(比较的是地址)</p>
</li>
<li><p>false类型的数据：false、0、” “、undefined、null、NaN</p>
</li>
<li><p>数据转换成数字0的情况:’’(空字符串),’ ‘(空格字符串),’0’,false,null,[ ]</p>
<span id="more"></span></li>
<li><p>栈：先进后出，每一个值占内存一个单元，存储空间是内存自动分配的</p>
</li>
<li><p>堆：程序员动态分配存储位置，没有顺序</p>
</li>
</ul>
<h3 id="逻辑运算符-amp-amp-、-、"><a href="#逻辑运算符-amp-amp-、-、" class="headerlink" title="逻辑运算符 &&、||、!"></a>逻辑运算符 &amp;&amp;、||、!</h3><ul>
<li>&amp;&amp;与：两个条件都为真，结果才是真，第一个为假，则不会继续执行，直接返回假</li>
<li>||或：两个条件有一个为真时，结果为真，第一个为真，则不会继续执行，直接返回</li>
<li>! 非：表示反取操作，将真变为假，将假变为真 </li>
</ul>
<h3 id="js数据类型转换"><a href="#js数据类型转换" class="headerlink" title="js数据类型转换"></a>js数据类型转换</h3><ul>
<li><p>隐式数据类型转换：</p>
<ul>
<li><p>数字和字串符相加的时候，会将数字转成字符串类型，然后再尾部拼接</p>
</li>
<li><p>数字和字符串减、乘、除的时候，会将数字字串符转成数字类型，然后再进行运算，如果字符串为非纯数字，因此无法完全解析为数字，减、乘、除数字结果为NaN</p>
</li>
</ul>
</li>
<li><p>显示类型转换：</p>
<ul>
<li><p>字符串转换：String() 、toString() </p>
</li>
<li><p>转换成数字：Number()、parseInt() 和 parseFloat() </p>
</li>
<li><p>转换成布尔值：Boolean()</p>
</li>
</ul>
</li>
</ul>
<h3 id="js判断数据类型"><a href="#js判断数据类型" class="headerlink" title="js判断数据类型 **"></a>js判断数据类型 **</h3><p><strong>typeof</strong>、<strong>instanceof</strong>、<strong>constructor</strong>、Object.prototype.toString.call()</p>
<ul>
<li><strong>typeof</strong>：是一个操作符，返回一个表达式的数据类型，例如<code>typeof 123</code>返回<code>"number"</code>。</li>
<li><strong>instanceof</strong>：是用来判断一个值是否为某个对象的实例，例如<code>[1, 2, 3] instanceof Array</code>返回<code>true</code>。</li>
<li><strong>constructor</strong>：是一个属性，返回一个值的构造函数的引用，例如<code>(123).constructor === Number</code>返回<code>true</code>。</li>
<li>Object.prototype.toString.call()：是一个方法，返回一个值的内部属性，例如<code>Object.prototype.toString.call("123")</code>返回<code>"[object String]"</code>。</li>
</ul>
<h3 id="判断一个对象为空"><a href="#判断一个对象为空" class="headerlink" title="判断一个对象为空"></a>判断一个对象为空</h3><ul>
<li><code>JSON.stringify(data) === '{}'</code>它可以通过将对象转为字符串来判断是否为空</li>
<li><code>Object.keys(data).length</code>.它是通过判断对象自身有没有key 值来判断是否为空的</li>
<li><code>Object.values(data).length</code>通过判断对象是否有value值来判断是否为空对象的</li>
<li>使用 <code>for...in</code> 循环</li>
<li>如果对象为空，它们将返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li>这些方法只会检查对象本身的属性，而不会检查原型链上的属性。如果希望同时检查原型链上的属性，请使用 <code>hasOwnProperty()</code> 方法进行判断。</li>
</ul>
<h3 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别 **"></a>null 和 undefined 的区别 **</h3><ul>
<li>null 是一个字面量，表示一个空对象的引用，而 undefined 是一个全局变量，表示一个未初始化的值</li>
<li>null 是一个对象类型，而 undefined 是一个未定义类型</li>
<li>null 在数字运算中被转换为 0，而 undefined 被转换为 NaN</li>
<li>null 和 undefined 在相等运算符（==）下相等，但在全等运算符（===）下不相等</li>
<li>null 是对象原型链的终点</li>
</ul>
<h3 id="js的作用域和作用域链"><a href="#js的作用域和作用域链" class="headerlink" title="js的作用域和作用域链 **"></a>js的作用域和作用域链 **</h3><p>JavaScript 的作用域是指代码中定义变量的区域，它决定了变量的可见性和生命周期。JS作用域主要包括全局作用域、局部作用域和ES6的块级作用域</p>
<ul>
<li><strong>全局作用域</strong>：在任何函数外部定义的变量，它可以在任何地方被访问，</li>
<li><strong>局部作用域</strong>：在函数内部定义的变量,是局部变量，只能在函数内部使用</li>
<li><strong>块级作用域</strong>：块级作用域是指在一对花括号内定义的变量，它只能在花括号内被访问，<code>js</code> 中使用 <code>let</code> 和 <code>const</code> 关键字可以创建块级作用域，块级作用域可以避免变量提升和暂时性死区的问题。</li>
</ul>
<p>JavaScript 的<strong>作用域链</strong>是指在查找变量时，沿着嵌套的作用域逐级向上搜索的路径。JavaScript 引擎遵循以下规则来解析变量：</p>
<ul>
<li><strong>先从当前作用域开始查找</strong>：如果当前作用域有该变量，就直接使用它；如果没有，就继续下一步。</li>
<li><strong>再从上一级作用域查找</strong>：如果上一级作用域有该变量，就使用它；如果没有，就继续下一步。</li>
<li><strong>重复上述步骤，直到全局作用域</strong>：如果全局作用域有该变量，就使用它；如果没有，就抛出一个引用错误</li>
</ul>
<h3 id="for-in-和-for-of-循环的区别"><a href="#for-in-和-for-of-循环的区别" class="headerlink" title="for in 和 for of 循环的区别 ?"></a>for in 和 for of 循环的区别 ?</h3><ul>
<li><code>for...in</code> 用于遍历对象的属性，包括继承的属性，返回属性名（字符串）。</li>
<li><code>for...of</code> 用于遍历可迭代对象的元素，返回元素的值，适用于数组、字符串等。</li>
</ul>
<p>在遍历数组时，推荐使用 <code>for...of</code>，因为它更直观且不会包括数组原型链上的属性。而 <code>for...in</code> 更适合用于遍历对象的属性。</p>
<h3 id="forEach和map有什么区别"><a href="#forEach和map有什么区别" class="headerlink" title="forEach和map有什么区别"></a>forEach和map有什么区别</h3><p><strong>返回值：</strong></p>
<ul>
<li><code>forEach</code>没有返回值，它只是对数组中的每个元素执行指定的操作。</li>
<li><code>map</code>返回一个新数组，该数组由原数组中的每个元素执行回调函数后的返回值组成。</li>
</ul>
<p><strong>使用目的：</strong></p>
<ul>
<li><code>forEach</code>用于在遍历数组时执行一些操作，例如修改数组元素的值、打印元素等。</li>
<li><code>map</code>用于创建一个新数组，该数组的元素是根据原始数组中的元素经过回调函数处理后得到的。</li>
</ul>
<p><strong>对原数组的影响：</strong></p>
<ul>
<li><code>forEach</code>不会改变原数组的值。 </li>
<li><code>map</code>不会改变原数组，但会返回一个新数组。</li>
</ul>
<h3 id="js创建对象的几种方式"><a href="#js创建对象的几种方式" class="headerlink" title="js创建对象的几种方式"></a>js创建对象的几种方式</h3><ul>
<li><p>工厂模式：工厂模式是用函数来封装创建对象的细节，在函数里面创建对象并返回对象</p>
</li>
<li><p>构造函数模式：使用一个自定义的函数作为构造函数，然后用 new 关键字创建一个新对象</p>
</li>
<li><p>原型模式：使用一个对象作为另一个对象的原型，然后用 Object.create() 方法创建一个新对象，这样可以实现继承和共享属性和方法</p>
</li>
<li><p>组合使用构造函数模式和原型模式：构造函数用于定义实例属性，原型用于定义共享的属性和方法。 </p>
<p>* 不成文的规定</p>
<p>如果函数名以大写字母开头 我们认为它是一个构造函数 配合new关键字使用</p>
<p>如果函数名是小写字母开头 我们认为它是一个普通函数 直接调用即可</p>
<p>this关键字两种场景: </p>
<p>1、构造函数中使用代表的是当前实例化对象 谁new了我 我就指向谁</p>
<p>2、全局环境中 this指向window 如果我们在全局中调用了函数 那么函数中的this就是指向window 谁调用我 我就指向谁</p>
</li>
</ul>
<h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><ul>
<li>箭头函数中的this指向的是定义时的this，而不是执行时的this，普通函数的this，谁调用就指向谁，没有调用者，就指向全局对象，</li>
<li>箭头函数没有自己的this，继承父类的this，不能作为构造函数使用，call，apply，bind，不能改变箭头函数的this指向，没有自己的arguments，没有prototype</li>
</ul>
<h3 id="js实现继承的几种方式"><a href="#js实现继承的几种方式" class="headerlink" title="js实现继承的几种方式 **"></a>js实现继承的几种方式 **</h3><p>ES5实现继承主要是基于prototype来实现的，具体有三种方法<br>原型链继承：即 B.prototype=new A()<br>借用构造函数继承：(call或者apply的方式继承)</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat2</span>(<span class="params">name</span>) {</span><br><span class="line">    <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name || <span class="string">'Tom'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> <span class="title class_">Cat2</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat2.<span class="property">name</span>); <span class="comment">//Tom</span></span><br></pre></td></tr></table></figure></div>

<p>组合继承：组合继承是结合第一种和第二种方式</p>
<p>ES6继承：使用<code>class</code>关键字定义一个类，使用<code>extends</code>关键字来继承父类，使用<code>super</code>关键字调用父类的构造函数</p>
<h3 id="new操作符具体干了什么"><a href="#new操作符具体干了什么" class="headerlink" title="new操作符具体干了什么"></a>new操作符具体干了什么</h3><p>创建一个空对象，作为新创建的实例对象</p>
<p>将这个空对象原型，指向构造函数的原型，实现原型链继承</p>
<p>将构造函数的this指向这个空对象，调用构造函数，给对象添加属性和方法</p>
<p>返回这个对象，如果构造函数没有返回其他对象或函数，则默认返回这个对象。</p>
<h3 id="和-有什么区别"><a href="#和-有什么区别" class="headerlink" title="==和===有什么区别"></a>==和===有什么区别</h3><ul>
<li><code>==</code>运算符在进行比较时，会进行类型转换。如果两个操作数的类型不同，那么<code>==</code>运算符会尝试将它们转换为相同的类型，然后再进行比较。这个过程被称为类型强制转换。</li>
<li>而<code>===</code>运算符在进行比较时，不会进行类型转换。如果两个操作数的类型不同，那么<code>===</code>运算符会返回<code>false</code>。</li>
</ul>
<h3 id="call、apply、bind的区别"><a href="#call、apply、bind的区别" class="headerlink" title="call、apply、bind的区别"></a>call、apply、bind的区别</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">func.<span class="title function_">call</span>(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></div>

<p>call：<code>call</code> 方法用于调用函数，并将一个指定的 <code>this</code> 值和若干个参数传递给函数。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">func.<span class="title function_">apply</span>(thisArg, [argsArray])</span><br></pre></td></tr></table></figure></div>

<p>apply：<code>apply</code> 方法也用于调用函数，和 <code>call</code> 类似，但是它接受一个包含参数的数组作为参数。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">func.<span class="title function_">bind</span>(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></div>

<p>bind：<code>bind</code> 方法创建一个新的函数，当被调用时将其 <code>this</code> 关键字设置为提供的值</p>
<p><strong>总结</strong>：</p>
<ul>
<li>三者都用于改变this指向</li>
<li><code>call</code> 和 <code>apply</code> 会立即调用函数，而 <code>bind</code> 会返回一个新的函数。</li>
<li><code>call</code> 和 <code>apply</code> 的区别在于传参方式，<code>call</code> 是接收参数列表，而 <code>apply</code> 是接收一个参数数组。</li>
<li><code>bind</code> 不会立即调用函数，而是返回一个新的函数，可以在后续调用。</li>
</ul>
<h3 id="说一下JS原生常用dom操作方法？"><a href="#说一下JS原生常用dom操作方法？" class="headerlink" title="说一下JS原生常用dom操作方法？"></a>说一下JS原生常用dom操作方法？</h3><ul>
<li><p>js原生dom操作方法有</p>
<ul>
<li>查找：<ul>
<li>getElementByid,</li>
<li>getElementsByTagName,</li>
<li>querySelector,</li>
<li>querySelectorAll</li>
</ul>
</li>
<li>插入：<ul>
<li>appendChild,insertBefore</li>
</ul>
</li>
<li>删除：<ul>
<li>removeChild</li>
</ul>
</li>
<li>克隆：<ul>
<li>cloneNode</li>
</ul>
</li>
<li>设置和获取属性：<ul>
<li>setAttribute(“属性名”,”值”)</li>
<li>getAttibute(“属性名”)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="什么是JavaScript原型，原型链-有什么特点？"><a href="#什么是JavaScript原型，原型链-有什么特点？" class="headerlink" title="什么是JavaScript原型，原型链 ? 有什么特点？ **"></a>什么是JavaScript原型，原型链 ? 有什么特点？ **</h3><ul>
<li><strong>原型</strong>：JavaScript中的每个函数都有一个 prototype 属性，这个属性指向一个对象，这个对象就是函数的原型对象。原型对象包含了函数的共享属性和方法，可以被函数的所有实例继承。</li>
<li><strong>原型链</strong>：JavaScript中的每个对象都有一个 <code>__proto__</code> 属性，这个属性指向对象的原型，也就是构造函数的 prototype 属性。通过 <code>__proto__</code>  属性，对象可以访问到原型上的属性和方法。原型对象也有自己的<code>__proto__</code> 属性，指向更上一层的原型，这样就形成了一个链式结构，称为原型链。原型链的终点是 Object.prototype ，它的<code>__proto__</code> 属性指向 null 。</li>
<li>特点：</li>
<li>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变，当我们需要查找一个属性时， Javascript 引擎会先看当前对象中是否有这个属性， 如果没有的就会查找他的Prototype 对象是否有这个属性，如此递推下去，一直检索到Object 内建对象</li>
</ul>
<h3 id="构造函数-实例对象-原型三者之间的关系"><a href="#构造函数-实例对象-原型三者之间的关系" class="headerlink" title="构造函数 实例对象 原型三者之间的关系"></a>构造函数 实例对象 原型三者之间的关系</h3><p>构造函数通过原型创建实例对象，实例对象通过原型链与原型建立关联，并可以共享原型上的属性和方法。</p>
<ul>
<li><p>首先，<strong>构造函数</strong>有一个<strong>prototype属性</strong>指向它的prototype原型对象；</p>
</li>
<li><p>所有<strong>原型对象</strong>都会自动获得一个 <strong>constructor</strong>（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针，即指向构造函数；</p>
</li>
<li><p>由构造函数new出来的<strong>实例对象</strong>，实例对象上有一个<code>__proto__</code>指向构造函数中的prototype原型对象。</p>
</li>
<li><p>两个方法：</p>
<ul>
<li>isPrototypeOf()：是 Object.prototype 的一个实例方法，用于判断当前对象是否为另一个对象的原型。接受对象作为参数，返回值为Boolean，如果参数不是对象，会被强制转成对象，参数为null或undefined则返回false</li>
<li>Object.getPrototypeOf()：是 Object 函数（类）的一个静态方法，用于获取指定对象的原型对象（即内部 [[Prototype]] 属性的值）。它接受一个对象作为参数，返回该对象的原型对象，可能是 null 。如果参数不是对象，它会被强制转换为对象。如果参数是 null 或 undefined ，它会抛出 TypeError 异常</li>
</ul>
</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li><p>闭包是指在一个函数内部创建的函数，它可以访问和操作外部函数的变量和参数，即使外部函数已经执行完毕，闭包仍然可以保持对这些变量的引用。</p>
</li>
<li><p><strong>好处</strong>：闭包有以下几个好处：</p>
<ul>
<li>保护函数内部的变量，实现变量的私有化和安全性。</li>
<li>保存函数内部的变量，保持上一次的状态，实现一些计数器、缓存、记忆等功能。</li>
<li>可以延长作用域，使其在函数可以在外部被访问和使用</li>
</ul>
</li>
<li><p><strong>缺点</strong>：闭包有以下几个缺点：</p>
<ul>
<li>常驻内存，增加内存消耗，导致内存泄漏。</li>
<li>增加代码的复杂度和理解难度，可能导致逻辑混乱。</li>
<li>命名冲突或污染全局作用域。</li>
</ul>
</li>
<li><p>在不需要使用闭包时将其赋值为 null ，让垃圾回收机制回收它，解决内存泄露</p>
</li>
</ul>
<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><ul>
<li><strong>不改变原数组的方法</strong>：这些方法不会修改原数组，而是返回一个新的数组或其他值。例如：<ul>
<li>concat()：用于连接两个或多个数组，返回一个新的数组。</li>
<li>join()：用于将数组中的所有元素转换为字符串，并连接成一个字符串，返回该字符串。</li>
<li>slice()：用于从数组中截取一部分元素，返回一个新的数组。</li>
<li>indexOf()：用于查找数组中指定元素的第一个索引，如果不存在，返回-1。</li>
<li>lastIndexOf()：用于查找数组中指定元素的最后一个索引，如果不存在，返回-1。</li>
<li>includes()：用于判断数组中是否包含指定元素，返回布尔值。</li>
<li>find()：用于查找数组中满足条件的第一个元素，返回该元素，如果没有找到，返回undefined。</li>
<li>findIndex()：用于查找数组中满足条件的第一个元素的索引，返回该索引，如果没有找到，返回-1。</li>
<li>filter()：用于过滤数组中满足条件的所有元素，返回一个新的数组。</li>
<li>map()：用于对数组中的每个元素进行操作，并返回一个新的数组。</li>
<li>forEach()：用于遍历数组中的每个元素，并执行回调函数，没有返回值。</li>
<li>reduce()：用于对数组中的每个元素进行累积操作，并返回最终结果。</li>
<li>some()：用于判断数组中是否有至少一个元素满足条件，返回布尔值。</li>
<li>every()：用于判断数组中是否所有元素都满足条件，返回布尔值。</li>
</ul>
</li>
<li><strong>改变原数组的方法</strong>：这些方法会修改原数组，并可能返回一些值。例如：<ul>
<li>push()：用于向数组末尾添加一个或多个元素，并返回新的长度。</li>
<li>pop()：用于删除数组末尾的一个元素，并返回该元素。</li>
<li>unshift()：用于向数组开头添加一个或多个元素，并返回新的长度。</li>
<li>shift()：用于删除数组开头的一个元素，并返回该元素。</li>
<li>splice()：用于在指定位置插入、删除或替换若干个元素，并返回被删除的元素组成的数组。</li>
<li>reverse()：用于反转数组中的元素顺序，并返回原数组。</li>
<li>sort()：用于对数组中的元素进行排序，并返回原数组。</li>
<li>fill()：用于将数组中指定范围内的所有元素填充为同一个值，并返回原数组。</li>
<li>copyWithin()：用于将数组中指定范围内的一段元素复制到另一段位置，并覆盖原有元素，并返回原数组。</li>
</ul>
</li>
</ul>
<h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><ul>
<li><strong>不改变原字符串的方法</strong>：这些方法不会修改原字符串，而是返回一个新的字符串或其他值。例如：<ul>
<li>charAt(x)：用于返回字符串中指定位置的字符，位置从0开始计算。</li>
<li>charCodeAt(x)：用于返回字符串中指定位置的字符的Unicode编码值。</li>
<li>indexOf(s)：用于查找字符串中指定子串s的第一个出现的位置，如果不存在，返回-1。</li>
<li>lastIndexOf(s)：用于查找字符串中指定子串s的最后一个出现的位置，如果不存在，返回-1。</li>
<li>includes(s)：用于判断字符串中是否包含指定子串s，返回布尔值。</li>
<li>startsWith(s)：用于判断字符串是否以指定子串s开头，返回布尔值。</li>
<li>endsWith(s)：用于判断字符串是否以指定子串s结尾，返回布尔值。</li>
<li>slice(x, y)：用于从字符串中截取从位置x到位置y（不包括y）之间的子串，返回该子串。</li>
<li>substring(x, y)：用于从字符串中截取从位置x到位置y（不包括y）之间的子串，如果x大于y，会自动交换位置，返回该子串。</li>
<li>substr(x, n)：用于从字符串中截取从位置x开始的n个字符，返回该子串。</li>
<li>split(s)：用于将字符串按照指定分隔符s分割成若干个子串，并返回一个数组。</li>
<li>match：用于将字符串与一个正则表达式r进行匹配，并返回一个数组，包含匹配结果和捕获组。</li>
<li>search：用于将字符串与一个正则表达式r进行匹配，并返回第一个匹配结果的位置，如果没有匹配，返回-1。</li>
<li>replace(r, s)：用于将字符串中与一个正则表达式r或者一个子串匹配的部分替换为另一个子串s，并返回替换后的新字符串。</li>
<li>repeat(n)：用于将字符串重复n次，并返回重复后的新字符串。</li>
<li>toLowerCase()：用于将字符串中的所有大写字母转换为小写字母，并返回转换后的新字符串。</li>
<li>toUpperCase()：用于将字符串中的所有小写字母转换为大写字母，并返回转换后的新字符串。</li>
<li>trim()：用于去除字符串两端的空白字符，并返回去除后的新字符串。</li>
</ul>
</li>
<li><strong>改变原字符串的方法</strong>：这些方法会修改原字符串，并可能返回一些值。例如：<ul>
<li>concat(s1, s2, …)：用于连接两个或多个字符串，并返回连接后的新字符串。注意，这个方法不会改变原始变量所指向的内存地址，而是创建了一个新的内存地址来存储连接后的新字符串。因此，在使用这个方法时，需要重新赋值给原始变量才能更新原始变量的值。</li>
</ul>
</li>
</ul>
<h3 id="在-JS-中如何阻止事件冒泡"><a href="#在-JS-中如何阻止事件冒泡" class="headerlink" title="在 JS 中如何阻止事件冒泡 ?"></a>在 JS 中如何阻止事件冒泡 ?</h3><p>使用event.stopPropagation()方法来阻止事件冒泡</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"myElement"</span>).<span class="title function_">addEventListener</span>(<span class="string">"click"</span>, <span class="keyword">function</span>(<span class="params">event</span>){  </span><br><span class="line">  event.<span class="title function_">stopPropagation</span>();  </span><br><span class="line">});</span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，阻止事件冒泡只是阻止了事件的传播，但并不会阻止事件的其他默认行为（例如，点击链接仍然会打开新的页面）。如果你想阻止事件的默认行为，你可以使用event.preventDefault()方法。</p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域 **"></a>跨域 **</h3><ul>
<li>什么时候跨域? 介绍同源策略<ul>
<li>什么时候跨域：协议，域名，端口号有一个不一致就会跨域</li>
<li>同源策略：所谓的同源策略其实是浏览器的一种机制，只允许在同源，也就是同协议、同域名、同端口的的情况下才能进行数据交互。</li>
</ul>
</li>
<li>跨域的方式有哪几种?<ul>
<li>JSONP</li>
<li>iframe</li>
</ul>
<ul>
<li>cors 解决跨域</li>
<li>proxy 代理（常用）</li>
<li>Nginx 反向代理（公司常用）</li>
</ul>
</li>
</ul>
<h3 id="jsonp的原理"><a href="#jsonp的原理" class="headerlink" title="jsonp的原理 **"></a>jsonp的原理 **</h3><ul>
<li>定义一个回调函数，动态创建script标签 利用script标签的src属性发起请求，在请求的路径后面添加一个callback参数，指定回调函数名，服务器会返回一个函数调用，通过形参接收函数调用传过来的实参，只能发起get请求 </li>
</ul>
<h3 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h3><ol>
<li><em><strong>数据传输方式：</strong></em></li>
</ol>
<ul>
<li><strong>GET</strong>：通过 URL 提交数据，数据会附在 URL 后面，以 <code>?</code> 分割。GET 请求的数据会被添加到 URL 中，可以在地址栏中看到，因此不适合传输敏感信息。</li>
<li><strong>POST</strong>：通过 HTTP 请求的主体提交数据，数据不会附在 URL 后面。POST 请求的数据会被包含在请求体中，相对安全，适合传输敏感信息。</li>
</ul>
<ol start="2">
<li><em><strong>数据传输大小：</strong></em></li>
</ol>
<ul>
<li><strong>GET</strong>：由于数据是附在 URL 中的，所以传输数据的大小受到 URL 长度的限制，一般在 2KB 到 8KB 之间。GET 请求的数据量较小，适合用于获取数据。</li>
<li><strong>POST</strong>：由于数据是包含在请求体中的，所以理论上没有大小限制，可以传输大量数据。POST 请求适合用于提交表单数据、上传文件等操作。</li>
</ul>
<ol start="3">
<li><em><strong>缓存：</strong></em></li>
</ol>
<ul>
<li><strong>GET</strong>：可以被缓存，可以被收藏为书签，可以保留在浏览器历史记录中。</li>
<li><strong>POST</strong>：不会被缓存，不会被收藏为书签，不会保留在浏览器历史记录中。</li>
</ul>
<h3 id="如何创一个原生ajax"><a href="#如何创一个原生ajax" class="headerlink" title="如何创一个原生ajax **"></a>如何创一个原生ajax **</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建ajax核心对象</span></span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">    <span class="comment">// 设置请求的方法、URL 和是否异步</span></span><br><span class="line">    <span class="comment">//    - 参数1: 请求路径 常用的有: get(获取) post(提交) delete(删除) put(修改) patch(打补丁的修改)</span></span><br><span class="line">    <span class="comment">//    - 参数2: 请求路径 url</span></span><br><span class="line">    <span class="comment">//    - 参数3: boolean类型 默认为true 表示同步(false)或异步(true)</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">'get'</span>, <span class="string">'https://api.it120.cc/fyy/shop/goods/list'</span>, <span class="literal">true</span>)</span><br><span class="line">	<span class="comment">//设置请求头</span></span><br><span class="line">	xhr.<span class="title function_">setRequestHeader</span>(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>); <span class="comment">// 设置请求头，指定请求的数据类型</span></span><br><span class="line">    <span class="comment">// 监听服务端响应</span></span><br><span class="line">	<span class="comment">// 使用 onreadystatechange 事件来监听请求状态的变化。当请求状态变化时，会触发该事件，并可以在事件处理程序中对请求状态进行处理。</span></span><br><span class="line">  xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) {</span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) {</span><br><span class="line">        <span class="keyword">const</span> responseData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Response:'</span>, responseData);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">'Request failed with status:'</span>, xhr.<span class="property">status</span>);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line"> xhr.<span class="title function_">send</span>();</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line"><span class="comment">// 使用 send() 方法发送请求。如果是 GET 请求，可以不传递参数；如果是 POST 或其他请求，可以通过传递参数（如 JSON 字符串或 FormData 对象）来发送请求。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（未初始化）还没有调用send()方法</span></span><br><span class="line"><span class="comment">//（载入）已调用send()方法，正在发送请求；</span></span><br><span class="line"><span class="comment">//（载入完成）send()方法执行完成，已经接收到全部响应内容</span></span><br><span class="line"><span class="comment">//（交互）正在解析响应内容</span></span><br><span class="line"><span class="comment">//（完成）响应内容解析完成，可以在客户端调用了</span></span><br></pre></td></tr></table></figure></div>

<h3 id="ajax的通信原理是什么或者axios的原理是什么"><a href="#ajax的通信原理是什么或者axios的原理是什么" class="headerlink" title="ajax的通信原理是什么或者axios的原理是什么?"></a>ajax的通信原理是什么或者axios的原理是什么?</h3><ul>
<li>ajax的通信原理是通过<strong>XmlHttpRequest对象</strong>来向服务器发送<strong>异步请求</strong>，从服务器获得数据，然后用<strong>JavaScript</strong>来操作<strong>DOM</strong>而更新页面。<ul>
<li>创建一个XmlHttpRequest对象，这个对象是ajax的核心，它提供了一系列的方法和属性来实现异步通信。</li>
<li>调用XmlHttpRequest对象的open()方法，设置请求的URL，方法（GET或POST），是否异步（true或false），以及可选的回调函数。</li>
<li>调用XmlHttpRequest对象的send()方法，发送请求，如果是POST方法，还需要设置请求头和请求体。</li>
<li>监听XmlHttpRequest对象的readyState属性和status属性，当readyState为4且status为200时，表示请求成功完成。</li>
<li>获取XmlHttpRequest对象的responseText或responseXML属性，根据返回的数据格式（文本或XML），进行解析和处理。</li>
<li>使用JavaScript来操作DOM，根据返回的数据动态地更新页面内容。</li>
</ul>
</li>
</ul>
<ul>
<li><p>axios的原理是基于<strong>promise</strong>对<strong>ajax</strong>进行了封装，使得它能够支持更多的功能和灵活性。</p>
<ul>
<li>axios对外暴露了一个axios实例，这个实例有一个Axios方法，这个方法是用来发送请求的核心。</li>
<li>Axios方法有一个interceptors对象，这个对象有request和response两个属性，分别用来管理请求拦截器和响应拦截器。</li>
<li>当我们调用axios.interceptors.request.use()或axios.interceptors.response.use()时，就会在对应的拦截器数组中添加一个成功回调和一个失败回调。</li>
<li>当我们调用axios或axios.get或axios.post等方法时，就会创建一个Promise对象，并将请求配置作为参数传入。</li>
<li>这个Promise对象会根据请求配置创建一个chain数组，这个数组存储了所有的回调函数，包括拦截器的回调和dispatchRequest的回调。</li>
<li>dispatchRequest是用来执行实际的请求的函数，它会根据不同的环境调用不同的适配器（adapter），例如在浏览器中调用XMLHttpRequest，在node.js中调用http模块。</li>
<li>适配器会对请求和响应进行处理，包括设置请求头，发送请求体，解析响应数据等，并返回一个响应对象（response）。</li>
<li>响应对象会被传递给chain数组中的下一个回调函数，直到所有的回调函数都执行完毕，最后返回一个最终的Promise对象。</li>
<li>我们可以在这个Promise对象上使用then或catch方法来处理响应数据或错误信息。</li>
</ul>
</li>
</ul>
<h3 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="comment">// 创建一个 Axios 实例</span></span><br><span class="line"><span class="keyword">const</span> apiClient = axios.<span class="title function_">create</span>({</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">'https://api.example.com'</span>, <span class="comment">// 替换成 API 地址</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">10000</span>, <span class="comment">// 请求超时时间（毫秒）</span></span><br><span class="line">  <span class="attr">headers</span>: {</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"><span class="comment">// 添加请求拦截器（可选）</span></span><br><span class="line">apiClient.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">config</span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么（例如添加认证信息）</span></span><br><span class="line">    <span class="comment">// config.headers['Authorization'] = 'Bearer ' + token;</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  },</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  }</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 添加响应拦截器（可选）</span></span><br><span class="line">apiClient.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">response</span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">// 对响应数据做些什么（例如解析数据）</span></span><br><span class="line">    <span class="keyword">return</span> response.<span class="property">data</span>;</span><br><span class="line">  },</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">// 对响应错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  }</span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> apiClient</span><br></pre></td></tr></table></figure></div>

<h3 id="封装ajax"><a href="#封装ajax" class="headerlink" title="封装ajax"></a>封装ajax</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ajax.js</span></span><br><span class="line"><span class="comment">// 封装一个 AJAX 请求函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url, options = {}</span>) {</span><br><span class="line">  <span class="comment">// 从 options 参数中提取请求方法、请求头和请求体，默认值为 GET 方法和空对象</span></span><br><span class="line">  <span class="keyword">const</span> { method = <span class="string">'GET'</span>, headers = {}, body = <span class="literal">null</span> } = options;</span><br><span class="line">  <span class="comment">// 使用 Fetch API 发送请求</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(url, {</span><br><span class="line">    method, <span class="comment">// 请求方法</span></span><br><span class="line">    <span class="attr">headers</span>: {</span><br><span class="line">      ...headers,</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>, <span class="comment">// 设置默认的 Content-Type 为 application/json</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">body</span>: body ? <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(body) : <span class="literal">null</span>, <span class="comment">// 将请求体转换成 JSON 字符串</span></span><br><span class="line">  })</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> {</span><br><span class="line">      <span class="comment">// 检查响应是否成功，否则抛出一个错误</span></span><br><span class="line">      <span class="keyword">if</span> (!response.<span class="property">ok</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'Network response was not ok'</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 解析 JSON 响应数据并返回</span></span><br><span class="line">      <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">    })</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">'Fetch Error:'</span>, error); <span class="comment">// 处理异常并打印错误信息</span></span><br><span class="line">      <span class="keyword">throw</span> error; <span class="comment">// 继续抛出错误，以便调用者可以处理它</span></span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 导出封装的 AJAX 请求函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ajax;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li></li>
</ul>
<h3 id="ajax、fetch、axios这三都有什么区别？"><a href="#ajax、fetch、axios这三都有什么区别？" class="headerlink" title="ajax、fetch、axios这三都有什么区别？"></a>ajax、fetch、axios这三都有什么区别？</h3><ol>
<li><strong>ajax</strong>:<ul>
<li><code>ajax</code> 是一种基于 XMLHttpRequest 对象的原生 JavaScript 方法，用于发送异步 HTTP 请求。</li>
<li>它可以处理各种类型的数据格式，如 JSON、XML、HTML 等。</li>
<li>使用 <code>ajax</code> 需要编写相对底层的代码，包括处理回调函数、状态码等，相对繁琐。</li>
</ul>
</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">javascriptCopy codevar xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">'GET'</span>, <span class="string">'https://api.example.com/data'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="title class_">XMLHttpRequest</span>.<span class="property">DONE</span>) {</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure></div>

<ol>
<li><strong>fetch</strong>:<ul>
<li><code>fetch</code> 是 ES6 引入的新的 API，也用于发送 HTTP 请求，提供了更现代化的方式来处理网络请求。</li>
<li><code>fetch</code> 返回的是一个 Promise 对象，使得处理异步请求更加方便。</li>
<li>默认情况下，<code>fetch</code> 不会拒绝 HTTP 错误状态。需要在 <code>then</code> 中手动检查 <code>response.ok</code> 来确定请求是否成功。</li>
</ul>
</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">javascriptCopy <span class="title function_">codefetch</span>(<span class="string">'https://api.example.com/data'</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> {</span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'Network response was not ok'</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">  })</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  })</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">'Error:'</span>, error));</span><br></pre></td></tr></table></figure></div>

<ol>
<li><strong>axios</strong>:<ul>
<li><code>axios</code> 是一个基于 Promise 的 HTTP 客户端，可以在浏览器和 Node.js 中使用。</li>
<li>它提供了更高层次的抽象，可以轻松地处理请求和响应，支持拦截器、并发请求等高级功能。</li>
<li><code>axios</code> 可以方便地处理 JSON 数据，并提供了更友好的 API。</li>
</ul>
</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeaxios.<span class="title function_">get</span>(<span class="string">'https://api.example.com/data'</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">  })</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">'Error:'</span>, error);</span><br><span class="line">  });</span><br></pre></td></tr></table></figure></div>

<p><strong>总结</strong>:</p>
<ul>
<li><code>ajax</code> 是原生的 JavaScript 方法，相对底层，需要手动处理回调函数和状态码。</li>
<li><code>fetch</code> 是现代的 API，返回 Promise 对象，提供了更方便的异步处理方式，但在处理 HTTP 错误时需要额外的检查。</li>
<li><code>axios</code> 是基于 Promise 的 HTTP 客户端，提供了更高级的功能和友好的 API，可以用于浏览器和 Node.js。</li>
</ul>
<h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>arguments 对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个 length 属性，我们可以使用数组索引表示法 arguments[1] 来访问单个值，但它没有数组中的内置方法，如：forEach、reduce、filter 和 map。</p>
<p>我们可以使用 Array.prototype.slice 将 arguments 对象转换成一个数组</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>箭头函数中没有arguments对象</p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>造成内存泄漏可能操作</p>
<ul>
<li>意外的全局变量</li>
<li>被遗忘的计时器或回调函数</li>
<li>脱离 DOM 的引用</li>
<li>闭包</li>
</ul>
<h3 id="从输入URL到页面加载完中间发生了什么"><a href="#从输入URL到页面加载完中间发生了什么" class="headerlink" title="从输入URL到页面加载完中间发生了什么 **"></a>从输入URL到页面加载完中间发生了什么 **</h3><ul>
<li>浏览器根据请求的url通过DNS解析成IP地址</li>
<li>根据IP地址建立TCP连接（三次握手）</li>
<li>发送HTTP请求</li>
<li>服务器处理请求，浏览器接收HTTP响应。</li>
<li>浏览器解析渲染页面</li>
<li>关闭TCP连接（四次挥手）  </li>
</ul>
<h3 id="常用的Git指令包括："><a href="#常用的Git指令包括：" class="headerlink" title="常用的Git指令包括："></a>常用的Git指令包括：</h3><ol>
<li><code>git init</code>：创建新的本地Git仓库。</li>
<li><code>git clone</code>：克隆一个远程Git仓库到本地。</li>
<li><code>git add</code>：将文件添加到暂存区，用于提交。</li>
<li><code>git commit</code>：提交暂存区中的文件到本地仓库。</li>
<li><code>git push</code>：将本地仓库的提交推送到远程仓库。</li>
<li><code>git pull</code>：从远程仓库拉取最新的更改。</li>
<li><code>git branch</code>：查看所有分支。</li>
<li><code>git checkout</code>：切换到指定的分支或文件。</li>
<li><code>git merge</code>：将指定分支合并到当前分支。</li>
<li><code>git rebase</code>：将指定分支的更改应用到当前分支。</li>
<li><code>git reset</code>：撤销添加到暂存区的文件或回退到指定的提交。</li>
<li><code>git log</code>：查看提交历史记录。</li>
<li><code>git reflog</code>：查看命令历史记录。</li>
<li><code>git branch -d</code>：删除指定分支（需要切换到其他分支）。</li>
<li><code>git push origin --delete</code>：删除远程分支。</li>
</ol>
<h3 id="什么是三次握手和四次挥手"><a href="#什么是三次握手和四次挥手" class="headerlink" title="什么是三次握手和四次挥手 ?"></a>什么是三次握手和四次挥手 ?</h3><ul>
<li>三次握手是网络客户端跟网络服务器之间建立连接，并进行通信的过程。相当于客户端和服务器之间你来我往的3个步骤。<ul>
<li>第一次握手是建立连接，客户端发送连接请求报文，并传送规定的数据包；</li>
<li>第二次握手是服务器端表示接收到连接请求报文，并回传规定的数据包；</li>
<li> 第三次握手是客户端接收到服务器回传的数据包后，给服务器端再次发送数据包。这样就完成了客户端跟服务器的连接和数据传送。</li>
</ul>
</li>
<li>四次挥手表示当前这次连接请求已经结束，要断开这次连接。<ul>
<li>第一次挥手是客户端对服务器发起断开请求，</li>
<li>第二次握手是服务器表示收到这次断开请求，</li>
<li>第三次握手是服务器表示已经断开连接</li>
<li>第四次握手是客户端断开连接。</li>
</ul>
</li>
</ul>
<h3 id="ES6模块与CommonJS模块有什么区别？"><a href="#ES6模块与CommonJS模块有什么区别？" class="headerlink" title="ES6模块与CommonJS模块有什么区别？"></a>ES6模块与CommonJS模块有什么区别？</h3><ul>
<li>1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li>
<li>2、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>
</ul>
<h3 id="DOM和BOM"><a href="#DOM和BOM" class="headerlink" title="DOM和BOM"></a>DOM和BOM</h3><ul>
<li><p>DOM</p>
<ul>
<li>DOM 是指将整个页面文档表示为一个树结构的对象模型，它将网页内容（如文本、图像等）以及与之相关的事件（如点击、移动等）封装为可以在编程语言中操作的对象。</li>
</ul>
</li>
<li><p>BOM</p>
<ul>
<li>BOM 是指将浏览器窗口及其内容（如地址栏、导航按钮等）作为对象模型，它提供了 JavaScript 访问和控制浏览器窗口的接口。</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>DOM 是用于访问和操作网页内容的接口，将页面表示为一个树结构的对象模型。</li>
<li>BOM 是用于访问和控制浏览器窗口的接口，提供了一系列的对象来操作浏览器的行为和状态。</li>
<li>DOM 和 BOM 是 JavaScript 与浏览器进行交互的重要手段，通过它们可以实现网页的动态效果、用户交互等功能。</li>
</ul>
</li>
</ul>
<h3 id="深拷贝浅拷贝"><a href="#深拷贝浅拷贝" class="headerlink" title="深拷贝浅拷贝"></a>深拷贝浅拷贝</h3><ul>
<li><p>浅拷贝：浅拷贝会直接复制引用类型的地址值，新旧对象的地址值一样 都指向同一块内存空间(共享) 所以对新对象的操作会影响到旧对象</p>
</li>
<li><p>深拷贝：深拷贝是复制了对象本身，新旧对象有自己独立的内存空间 所以对新对象的操作不会影响到旧对象</p>
</li>
<li><p>可以实现浅拷贝的方法：Object.assign()，展开运算符(…) </p>
</li>
<li><p>可以实现深拷贝的方法：递归复制，json.stringify和json.parse</p>
</li>
<li><p>深拷贝递归复制的原理是，通过递归遍历对象，检查每个属性和子对象是否是基本数据类型（例如数字和字符串）。如果是基本数据类型，则直接复制数据；如果不是基本数据类型，则递归地继续遍历并创建新的对象。此过程会创建一个全新的对象，该对象在内存中有自己的地址，与原始对象无关。这意味着修改复制后的对象不会影响原始对象。</p>
</li>
<li><p>```js<br>// 递归<br>function deepCopy(obj) {<br>  if (obj === null || typeof obj !== ‘object’) {</p>
<pre><code>return obj;
</code></pre>
<p>  }<br>  let copy = Array.isArray(obj) ? [] : {};<br>  for (let key in obj) {</p>
<pre><code>if (obj.hasOwnProperty(key)) {
  copy[key] = deepCopy(obj[key]);
}
</code></pre>
<p>  }<br>  return copy;<br>}<br>const deepCopyObj = deepCopy(originalObject);</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 解释 JavaScript 中“undefined”和“not defined”之间的区别</span><br><span class="line"></span><br><span class="line">- "undefined" 表示变量已经被声明，但尚未被赋值，或者属性存在但值未设置。</span><br><span class="line"></span><br><span class="line">- "not defined" 表示在当前作用域中没有找到该变量。</span><br><span class="line">- 当试图访问一个未声明的变量时，会抛出 `ReferenceError` 错误。</span><br><span class="line">- 当访问一个已声明但未被赋值的变量时，会返回 "undefined"。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 匿名和命名函数有什么区别？</span><br><span class="line"></span><br><span class="line">- **函数名**：匿名函数没有指定函数名，而命名函数有指定函数名</span><br><span class="line">- **调用方式**：匿名函数不能直接调用，需要赋值给一个变量或者作为参数传递给其他函数，而命名函数可以直接通过函数名调用</span><br><span class="line">- **作用域**：匿名函数可以创建一个独立的作用域，避免变量污染，而命名函数会在全局作用域或者所在的作用域中创建一个变量</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">// 匿名函数</span><br><span class="line">function () {</span><br><span class="line">  console.log("这是一个匿名函数");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 命名函数</span><br><span class="line">function foo() {</span><br><span class="line">  console.log("这是一个命名函数");</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="json和jsonp的区别"><a href="#json和jsonp的区别" class="headerlink" title="json和jsonp的区别?"></a>json和jsonp的区别?</h3><ul>
<li>json是一种数据交换格式，jsonp是一种跨域数据交互协议</li>
<li>json只能在同源的情况下获取数据，jsonp可以在跨域的情况下获取数据</li>
<li>json返回的是一串json格式数据；而jsonp返回的是脚本代码（包含一个函数调用）</li>
</ul>
<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><ul>
<li>在函数中，指向调用者</li>
</ul>
<ul>
<li>在事件中，指向触发事件的元素</li>
<li>在箭头函数中，上一层作用域的this指向</li>
<li>如果有new关键字this指向new出来的那个对象</li>
</ul>
<h3 id="cookie，localStorage和sessionStoreage"><a href="#cookie，localStorage和sessionStoreage" class="headerlink" title="cookie，localStorage和sessionStoreage"></a>cookie，localStorage和sessionStoreage</h3><ul>
<li>都用在客户端存储数据，每一个都有自己的存储和到期限制，</li>
<li>不同点：<ul>
<li>存储大小：<ul>
<li>cookie数据大小不能大于4k</li>
<li>localStorage和sessionStorage则可以达到5M</li>
</ul>
</li>
<li>有效时间<ul>
<li>cookie在设置的有效期内一直有效</li>
<li>localStorage存储持久数据，只要不手动清除则一直存在</li>
<li>sessionStorage数据在当前浏览器关闭后就会被自动清除</li>
</ul>
</li>
<li>数据与服务器间的交互方式<ul>
<li>cookie的数据会自动传递到服务器端，服务器端的也可以写cookie到客户端</li>
<li>localStorage和sessionStorage不会把数据自动传到服务器端，仅在本地存储</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="token-一般存放在哪里-为什么不存放在-cookie-内"><a href="#token-一般存放在哪里-为什么不存放在-cookie-内" class="headerlink" title="token 一般存放在哪里 ? 为什么不存放在 cookie 内 ?"></a>token 一般存放在哪里 ? 为什么不存放在 cookie 内 ?</h3><ul>
<li>token一般放在本地存储中。token的存在本身只关心请求的安全性，而不关心token本身的安全，因为token是服务器端生成的，可以理解为一种加密技术。但如果存在cookie内的话，浏览器的请求默认会自动在请求头中携带cookie，所以容易受到csrf攻击。</li>
</ul>
<h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流 **"></a>防抖和节流 **</h3><ul>
<li><p>防抖：在一定时间内，多次触发同一个事件，只执行最后一次操作。用于search搜索时，用户在不断输入值，用防抖来节约请求资源，</p>
</li>
<li><p>节流：在一定时间内，多次触发同一个事件，只执行第一次操作。用于点击按钮，页面滚动加载，比如是否滑到底部自动加载更多</p>
</li>
</ul>
<h3 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h3><ul>
<li><p>当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。</p>
</li>
<li><p>事件传播有三个阶段：</p>
<ul>
<li>1、捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。</li>
<li>2、目标阶段–事件已达到目标元素。</li>
<li>3、冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。</li>
</ul>
</li>
</ul>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><ul>
<li>在捕获阶段，事件从 window 开始，一直到触发事件的元素。<code>window----&gt; document----&gt; html----&gt; body \----&gt;目标元素</code></li>
</ul>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><ul>
<li>事件冒泡刚好与事件捕获相反，当前元素—-&gt;body -—&gt; html—-&gt;document -—&gt;window。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达 window 为止。</li>
</ul>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><ul>
<li>事件委托是利用事件冒泡机制，在父元素上监听子元素的事件。通过将事件处理函数绑定到父元素上，可以实现对动态添加的子元素也能够触发相同的事件处理逻辑。当事件冒泡到父元素时，可以通过判断事件的目标元素（<code>event.target</code>）来确定具体是哪个子元素触发了事件。</li>
<li>优点：<ul>
<li>节省内存，避免了每个子元素都能绑定事件处理函数</li>
<li>动态添加的子元素也能够绑定事件，无需重新绑定事件处理函数</li>
</ul>
</li>
<li>综上所述，事件传播是指在DOM结构中的传递过程，包括事件捕获阶段、目标阶段和事件冒泡阶段，事件委托是一种利用事件冒泡机制，在父元素上监听子元素事件的技术</li>
</ul>
<h3 id="css权重"><a href="#css权重" class="headerlink" title="css权重"></a>css权重</h3><p>CSS权重是一种用于确定样式优先级的规则，它决定了当多个规则应用到同一个元素时，哪一个规则会被应用。</p>
<p>CSS权重由不同的选择器组合和特定的选择器类型决定。常见选择器类型的权重从高到低如下：</p>
<p>!important：具有最高的权重。通过在样式规则中添加!important关键字，可以使该规则具有最高的优先级。<br>内联样式（Inline styles）：直接应用于HTML元素的内联样式表达式。内联样式的权重高于其他选择器。<br>ID选择器（ID Selectors）：通过ID属性选择元素，如#my-element。ID选择器具有比类选择器和标签选择器更高的权重。<br>类选择器、属性选择器和伪类选择器（Class Selectors, Attribute Selectors, Pseudo-class Selectors）：通过类名、属性或伪类选择元素，如.my-class、[type=”text”]、:hover。它们的权重相同。<br>标签选择器和伪元素选择器（Tag Selectors, Pseudo-element Selectors）：通过HTML标签名称或伪元素选择元素，如div、::before。它们的权重相同。<br>通配选择器和子选择器（Universal Selector, Child Selector）：选择所有元素或选择某个元素的直接子元素。它们的权重较低。</p>
<p>当多个规则应用到同一个元素上时，CSS权重规则如下：</p>
<p>权重值较高的规则胜出，即具有较高权重的样式将被应用。<br>如果两个规则具有相同的权重，则后定义的规则将胜出，即后面的样式将覆盖先前的样式。</p>
<p>需要注意的是，通过使用!important可以覆盖其他规则的权重，但滥用!important可能导致样式维护困难和不可预测的结果。因此，建议在编写样式时，尽量避免使用!important，并采用良好的选择器结构和规则定义来管理样式权重。</p>
<h3 id="实现元素垂直水平居中"><a href="#实现元素垂直水平居中" class="headerlink" title="实现元素垂直水平居中"></a>实现元素垂直水平居中</h3><ol>
<li><p>使用 Flexbox（弹性盒子布局）</p>
<p>.container {<br>  display: flex;<br>  justify-content: center; /* 水平居中 <em>/<br>  align-items: center; /</em> 垂直居中 */<br>}</p>
</li>
</ol>
<p>2.使用 Grid 布局</p>
<p>.container {<br>  display: grid;<br>  place-items: center; /* 水平垂直居中 */<br>}</p>
<p>3.使用绝对定位和 transform 属性</p>
<p>.container {<br>  position: relative;<br>}</p>
<p>.centered {<br>  position: absolute;<br>  top: 50%;<br>  left: 50%;<br>  transform: translate(-50%, -50%);<br>}</p>
<p>4.使用 table-cell 和 vertical-align</p>
<p>.container {<br>  display: table-cell;<br>  text-align: center;<br>  vertical-align: middle;<br>}</p>
<p>5.使用 Grid 布局的 justify-self 和 align-self</p>
<p>.container {<br>  display: grid;<br>}</p>
<p>.centered {<br>  justify-self: center; /* 水平居中 <em>/<br>  align-self: center; /</em> 垂直居中 */<br>}</p>
<p>6.使用 flex 布局的 margin 属性</p>
<p>.container {<br>  display: flex;<br>}</p>
<p>.centered {<br>  margin: auto; /* 在 flex 布局中，auto 的 margin 会将元素水平和垂直居中 */<br>}</p>
<h3 id="简述js的事件队列机制"><a href="#简述js的事件队列机制" class="headerlink" title="简述js的事件队列机制"></a>简述js的事件队列机制</h3><p>JavaScript中的事件队列机制是指将事件和任务按照顺序放入队列中，然后按照一定的规则从队列中取出并执行。主要包含以下几个概念：</p>
<ul>
<li>任务队列：用于存储异步事件的回调函数，比如定时器事件、网络请求的回调函数等</li>
<li>微任务队列：用于存储微任务（Promise的回调函数），微任务的优先级高于任务队列</li>
<li>宏任务：常见的宏任务包括setTimeout、setInterval、XHR等</li>
<li>微任务：执行栈为空时，会先处理微任务队列中的所有任务，然后再处理任务队列中的一个宏任务。微任务的执行顺序优先于宏任务</li>
<li>事件循环的过程：<ol>
<li>执行完当前执行栈中的同步代码</li>
<li>检查微任务队列，依次执行事件队列中的微任务</li>
<li>检查事件任务队列，选择事件队列中的一个宏任务</li>
<li>执行宏任务，执行过程中遇到的所有微任务将被添加到微任务队列中</li>
</ol>
</li>
</ul>
<h3 id="宏任务，微任务"><a href="#宏任务，微任务" class="headerlink" title="宏任务，微任务"></a>宏任务，微任务</h3><ol>
<li><strong>宏任务（Macro Task）</strong>：<ul>
<li>宏任务包括了整体的代码块、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>（Node.js 环境）等。</li>
<li>宏任务是由宿主环境（浏览器或 Node.js）提供的异步任务，它们会被放入任务队列中等待执行。</li>
<li>宏任务的执行顺序是由事件循环机制决定的，每次事件循环中只执行一个宏任务。</li>
</ul>
</li>
<li><strong>微任务（Micro Task）</strong>：<ul>
<li>微任务包括了<code>Promise</code>、<code>process.nextTick</code>（Node.js 环境）等。</li>
<li>微任务是在当前任务执行结束后立即执行的任务，不需要等待下一次事件循环。</li>
<li>微任务会在宏任务执行完毕后，当前宏任务的微任务队列中的任务按顺序执行。</li>
</ul>
</li>
</ol>
<p><strong>执行顺序</strong>：</p>
<ol>
<li>当一个宏任务执行完毕后，会查看它的微任务队列，如果有微任务，就会依次执行所有的微任务。</li>
<li>当所有微任务执行完毕后，会去执行下一个宏任务。</li>
</ol>
<p>简而言之，微任务会在当前宏任务执行完后立即执行，而不需要等待下一个宏任务。</p>
<h3 id="什么是事件循环"><a href="#什么是事件循环" class="headerlink" title="什么是事件循环"></a>什么是事件循环</h3><p>事件循环（Event Loop）是 JavaScript 引擎实现异步编程的一种机制，确保了 JavaScript 在单线程环境中也能处理异步任务。</p>
<p>在浏览器环境中，事件循环是由浏览器提供的，而在 Node.js 环境中，事件循环则是由 Node.js 提供的。</p>
<p>事件循环的基本原理如下：</p>
<ol>
<li>JavaScript 代码执行时，会被分成同步任务和异步任务两种。</li>
<li>同步任务会被放入调用栈（Call Stack）中，按照执行顺序依次执行。</li>
<li>异步任务会被放入相应的任务队列（Task Queue）中，等待被执行。</li>
<li>当调用栈为空时，事件循环会检查任务队列，将可以执行的异步任务（微任务和宏任务）放入调用栈中执行。<ul>
<li>微任务队列（Microtask Queue）：包括 <code>Promise</code> 的 <code>then</code> 方法、<code>process.nextTick</code>（Node.js 环境）等。</li>
<li>宏任务队列（Macrotask Queue）：包括 <code>setTimeout</code>、<code>setInterval</code>、<code>requestAnimationFrame</code>、I/O 操作等。</li>
</ul>
</li>
<li>重复步骤3和4，直到所有任务都被执行完毕。</li>
</ol>
<p>简而言之，事件循环确保了 JavaScript 在单线程环境中也能处理异步任务，保证了代码的执行顺序和异步操作的正确性。</p>
<p>需要注意的是，由于事件循环的存在，异步操作并不会立即执行，而是会在适当的时机被放入任务队列中，等待事件循环将其执行。这是 JavaScript 实现异步编程的核心机制之一。</p>
<h3 id="JavaScript-执行机制，同步任务、异步任务、微任务、宏任务、事件轮询"><a href="#JavaScript-执行机制，同步任务、异步任务、微任务、宏任务、事件轮询" class="headerlink" title="JavaScript 执行机制，同步任务、异步任务、微任务、宏任务、事件轮询"></a>JavaScript 执行机制，同步任务、异步任务、微任务、宏任务、事件轮询</h3><ol>
<li><strong>同步任务（Synchronous Task）</strong>：<ul>
<li>同步任务是按照代码在程序中出现的顺序依次执行的任务。</li>
<li>在执行同步任务时，如果某个任务耗时较长，会阻塞后续任务的执行。</li>
</ul>
</li>
<li><strong>异步任务（Asynchronous Task）</strong>：<ul>
<li>异步任务不会阻塞后续任务的执行，而是在特定条件下触发执行。</li>
<li>常见的异步任务包括网络请求、定时器、事件监听等。</li>
</ul>
</li>
<li><strong>宏任务（Macro Task）</strong>：<ul>
<li>宏任务包括整体的代码块、<code>setTimeout</code>、<code>setInterval</code>、I/O 操作等，通常由浏览器或 Node.js 提供。</li>
<li>宏任务会被放入宏任务队列中等待执行，执行完后会检查微任务队列是否有任务，如果有则依次执行微任务。</li>
</ul>
</li>
<li><strong>微任务（Micro Task）</strong>：<ul>
<li>微任务包括 <code>Promise</code>、<code>process.nextTick</code>（Node.js 环境）等，它们都是异步任务的一种特殊形式。</li>
<li>微任务会在当前宏任务执行完毕后立即执行，不需要等待下一个宏任务。</li>
</ul>
</li>
<li><strong>事件轮询（Event Loop）</strong>：<ul>
<li>事件轮询是 JavaScript 引擎处理异步任务的机制，确保了异步任务按照正确的顺序执行。</li>
<li>它包括了同步任务的执行、微任务的执行、宏任务队列的检查与执行等过程。</li>
</ul>
</li>
</ol>
<p>JavaScript 的执行机制可以简单概括为：</p>
<ol>
<li>执行同步任务，依次将任务压入调用栈（Call Stack）中执行。</li>
<li>当遇到异步任务时，将其交给相应的环境（浏览器或 Node.js）处理。</li>
<li>异步任务完成后，将其回调函数加入相应的任务队列（宏任务队列或微任务队列）中等待执行。</li>
<li>当调用栈为空时，从微任务队列开始执行所有微任务，直到微任务队列为空。</li>
<li>微任务执行完毕后，从宏任务队列中取出一个任务放入调用栈执行，重复步骤3和4，直到所有任务都被执行完毕。</li>
</ol>
<p>总的来说，JavaScript 的执行机制保证了同步任务的顺序执行，异步任务的按时机触发执行，微任务优先于宏任务执行。这种机制使得 JavaScript 在单线程环境中也能高效处理异步操作。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul>
<li>递归调用：函数在其自身内部调用自身。<ul>
<li>在递归过程中，函数会反复调用自身，每次调用时都会解决一个规模较小的子问题，直到达到某个终止条件，然后逐层返回结果，最终得到整个问题的解。</li>
</ul>
</li>
<li>终止条件：确定递归何时结束的条件，以避免无限递归。</li>
</ul>
<h3 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h3><ul>
<li>回流：当渲染树中的一部分或全部，因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就称为回流</li>
<li>重绘：当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，则称为重绘</li>
<li>两者的区别：回流必将引起重绘，而重绘不一定引起回流，比如：只有颜色改变的时候就只会发生重绘而不会引起回流，当页面布局和几何属性改变时就需要回流</li>
</ul>
<h3 id="怎么减少回流和重绘"><a href="#怎么减少回流和重绘" class="headerlink" title="怎么减少回流和重绘"></a>怎么减少回流和重绘</h3><ol>
<li><strong>使用<code>transform</code>和<code>opacity</code>代替<code>top</code>和<code>left</code>等属性</strong>：使用 <code>transform</code> 属性进行位移和旋转，而不是使用 <code>top</code> 和 <code>left</code>，因为 <code>transform</code> 不会引起回流和重绘。</li>
<li><strong>批量修改DOM</strong>：避免在循环中直接对DOM进行频繁的操作，可以先将需要修改的DOM元素的状态保存在一个变量中，然后一次性对DOM进行更新。</li>
<li><strong>使用文档片段（DocumentFragment）</strong>：使用文档片段进行多次DOM操作，最后将文档片段一次性添加到DOM中，减少了频繁的回流。</li>
<li><strong>将元素脱离文档流</strong>：在修改多个DOM元素样式时，可以先将元素设置为<code>display: none</code>，进行操作后再显示，这样可以避免频繁的回流。</li>
<li><strong>使用CSS动画代替JavaScript动画</strong>：CSS动画利用GPU加速，比JavaScript动画性能更好。</li>
<li><strong>避免触发布局属性</strong>：回流会发生在需要获取布局信息的属性上，如<code>offsetTop</code>、<code>offsetWidth</code>等，尽量避免频繁获取这些属性。</li>
<li><strong>使用分层（Layer）</strong>：将复杂的页面分成多个独立的图层，可以减少整体页面的回流和重绘。</li>
<li><strong>合理使用CSS will-change属性</strong>：可以通过 <code>will-change</code> 属性告诉浏览器哪些属性将会发生变化，从而优化渲染性能。</li>
<li><strong>优化图片和媒体资源</strong>：使用合适的图片格式和压缩级别，避免过大的媒体文件影响页面加载速度。</li>
<li><strong>避免频繁触发事件</strong>：尽量避免在高频触发事件（如<code>resize</code>、<code>scroll</code>）的回调中执行复杂的DOM操作。</li>
<li><strong>合理使用CSS Grid和Flexbox布局</strong>：使用现代的布局方式可以减少对DOM的频繁操作。</li>
<li><strong>懒加载和分页加载</strong>：对于大量数据或图片，可以采用懒加载或分页加载的方式，按需加载，避免一次性加载过多资源。</li>
</ol>
<h3 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h3><ul>
<li>新增了块级作用域(let,const)</li>
<li>提供了定义类的语法糖(class)</li>
<li>新增了一种基本数据类型(Symbol)</li>
<li>新增了变量的解构赋值</li>
<li>新增了箭头函数</li>
<li>新增模板字符串</li>
<li>对象和数组新增了扩展运算符</li>
<li>ES6 新增了模块化(import/export)</li>
<li>ES6 新增了 Set 和 Map 数据结构</li>
<li>新增Promise，处理异步操作</li>
<li>ES6 新增了生成器(Generator)和迭代器(Iterator)</li>
</ul>
<h3 id="ES6声明变量的六种方法"><a href="#ES6声明变量的六种方法" class="headerlink" title="ES6声明变量的六种方法"></a>ES6声明变量的六种方法</h3><ul>
<li>var，function，let，const，import，class</li>
</ul>
<h3 id="let与const以及var的区别？以及什么是暂时性死区？什么是变量提升？"><a href="#let与const以及var的区别？以及什么是暂时性死区？什么是变量提升？" class="headerlink" title="let与const以及var的区别？以及什么是暂时性死区？什么是变量提升？"></a>let与const以及var的区别？以及什么是暂时性死区？什么是变量提升？</h3><ul>
<li><p>var：预解析 变量提升 只提升变量名 不提升赋值，产生作用域</p>
</li>
<li><p>let 定义的变量不进行预解析，不进行变量提升，产生块级作用域{}</p>
</li>
<li><p>const 声明一个只读常量。一旦声明，常量的值就不能改变。产生块级作用域。(栈中的值)</p>
</li>
<li><p>暂时性死区</p>
<ul>
<li>使用 let 或 const 声明变量时，变量会被绑定到其所在的块级作用域。在变量被声明之前，它处于暂时性死区，即无法被访问。</li>
</ul>
</li>
<li><p>变量提升：先声明变量，再进行赋值</p>
</li>
</ul>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><ul>
<li> 使用反引号创建的字符串就是模板字符串 ``</li>
<li>模板字符串中的内容允许直接换行</li>
<li>解决了字符串和变量之间使用+拼接的繁琐工作，可以直接使用${}来识别变量</li>
</ul>
<h3 id="Object-assign-有什么作用"><a href="#Object-assign-有什么作用" class="headerlink" title="Object.assign()有什么作用"></a>Object.assign()有什么作用</h3><ul>
<li><code>Object.assign()</code> 方法用于将一个或多个源对象的可枚举属性复制到目标对象。它返回目标对象。</li>
</ul>
<p>​    语法：<code>Object.assign(target, ...sources)</code></p>
<ul>
<li><code>target</code>：目标对象。</li>
<li><code>sources</code>：一个或多个源对象。</li>
</ul>
<h3 id="你了解构造函数吗-class-是什么-两者有什么区别"><a href="#你了解构造函数吗-class-是什么-两者有什么区别" class="headerlink" title="你了解构造函数吗 ? class 是什么 ? 两者有什么区别 ?"></a>你了解构造函数吗 ? class 是什么 ? 两者有什么区别 ?</h3><p>在es5中构造函数其实就是在定义一个类，可以实例化对象，es6中class其实是构造函数的语法糖。</p>
<ul>
<li>在class内部和class的方法内部，默认使用严格模式</li>
<li>class类不存在预解析，也就是不能先调用class生成实例，再定义class类，但是构造函数可以。</li>
<li>class中定义的方法默认不能被枚举，也就是不能被遍历。</li>
<li>class必须使用new执行，但是构造函数没有new也可以执行。</li>
<li>class中的所有方法都没有原型，也就不能被new</li>
<li>class中继承可以继承静态方法，但是构造函数的继承不能。</li>
</ul>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul>
<li>普通函数表达式的简化语法</li>
<li>省略function关键字，在()和{}之间使用一个箭头连接</li>
<li>形参有且只有一个的时候，()也可以省略不写</li>
<li>当函数体中有且只有一条return语句时，可以省略{}及return关键字</li>
<li>有自己的this指向,会查找父级作用域的this</li>
<li>没有arguments实参的集合</li>
<li>因为为没有自己的this，所以不能作为构造函数使用</li>
</ul>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>在ES6中允许按照一定的模式从数组或者对象中提取想要的数据</p>
<p>​     左右两边的结构必须保持一致</p>
<p>​     声明和赋值不能分开</p>
<p>​    将繁琐的数据进行简单化处理</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的结构赋值</span></span><br><span class="line"> <span class="keyword">var</span> arr = [<span class="string">"张三"</span>, <span class="string">"李四"</span>, <span class="string">"王五"</span>]</span><br><span class="line"> <span class="keyword">var</span> [a, b, ...c] = arr</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 张三</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// 李四</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">// Array(1) </span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 对象的结构赋值</span></span><br><span class="line"> <span class="comment">// 对象的属性名和解构的变量名一一对应</span></span><br><span class="line">   <span class="keyword">var</span> obj = {</span><br><span class="line">     <span class="attr">name</span>: <span class="string">"张三"</span>,</span><br><span class="line">     <span class="attr">age</span>: <span class="string">"19"</span>,</span><br><span class="line">     <span class="attr">job</span>: <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"web前端"</span>)</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">var</span> { name, job,age } = obj</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">// 张三</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(age)  <span class="comment">// 19</span></span><br><span class="line">   <span class="title function_">job</span>() <span class="comment">// web前端</span></span><br></pre></td></tr></table></figure></div>

<h3 id="扩展运算符（…）"><a href="#扩展运算符（…）" class="headerlink" title="扩展运算符（…）"></a>扩展运算符（…）</h3><p>…(剩余运算符)的作用</p>
<p>分配不了的都给它</p>
<p>当剩余运算符在函数的形参中使用时，只允许出现在最后一个形参前面，表示剩下所有传递的实参都保存在这个参数中，以数组形式展示</p>
<p>剩余运算符还可以作为展开数组的作用来使用，这时我们一般称之为开展运算符，或者扩展运算符，可以利用这种语法实现</p>
<p>例如：数组合并 ，伪数组转换为真数组 等使用场景</p>
<p>当我们需要将一个数组的每一个项作为实参的每一个值传递时，最简单的方式就是使用扩展运算符</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment">// 使用扩展运算符合并</span></span><br><span class="line"><span class="keyword">var</span> arr4 = [...arr1,...arr2]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr4) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用扩展运算符找数组中最大值</span></span><br><span class="line"><span class="keyword">var</span> arr7 = [<span class="number">13</span>,<span class="number">21</span>,<span class="number">3</span>,<span class="number">3124</span>,<span class="number">32</span>,<span class="number">4532</span>,<span class="number">5</span>] </span><br><span class="line"><span class="keyword">let</span> maxNum = <span class="title class_">Math</span>.<span class="title function_">max</span>(...arr7)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(maxNum) <span class="comment">// 4532</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Set和Map区别"><a href="#Set和Map区别" class="headerlink" title="Set和Map区别"></a>Set和Map区别</h3><ul>
<li>（1）Map是键值对的集合，类似于对象，Set是值的集合，类似于数组，<strong>当然键和值可以是任何的值</strong>；</li>
<li>（2）Map可以通过get方法获取值，而set不能因为它只有值；</li>
<li>（3）都能通过迭代器进行for…of遍历；</li>
<li>（4）Set的值是唯一的，可以做数组去重，Map由于没有格式限制，可以做数据存储</li>
</ul>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><ul>
<li>ES6引入一个全新的数据类型 Symbol该类型表示独一无二的值，类型的展现方式类似于字符串<ul>
<li>Symbol值是唯一的，那么可以解决命名冲突问题</li>
<li>Symbol值不能和其他任何数据进行计算</li>
<li> Symbol定义的对象属性不能使用for in进行遍历 =，Reflect.ownkeys来获取所有的键名</li>
<li>Symbol()表示创建一个独一无二的值</li>
<li>Symbol.for()表示创建一个独一无二的地址</li>
</ul>
</li>
</ul>
<h3 id="Proxy是什么，有什么作用"><a href="#Proxy是什么，有什么作用" class="headerlink" title="Proxy是什么，有什么作用"></a>Proxy是什么，有什么作用</h3><p>ES6 中的 <code>Proxy</code> 是一个用于创建代理对象的构造函数，它允许你创建一个对象的代理，可以自定义该对象的行为。</p>
<p><code>Proxy</code> 的作用主要体现在以下几个方面：</p>
<ol>
<li><p><strong>拦截和自定义对象操作</strong>：</p>
<p>通过使用 <code>Proxy</code>，你可以拦截并自定义对象上的操作，比如读取属性、设置属性、调用方法等。这使得你可以在这些操作发生前后添加额外的逻辑。</p>
</li>
<li><p><strong>数据验证和保护</strong>：</p>
<p>可以使用 <code>Proxy</code> 来验证或保护对象的属性，例如，你可以阻止特定属性的写入或修改。</p>
</li>
<li><p><strong>实现双向绑定</strong>：</p>
<p><code>Proxy</code> 可以用于实现简单的数据绑定，当对象属性发生变化时，可以触发相应的操作。</p>
</li>
<li><p><strong>在对象之前建立拦截层</strong>：</p>
<p><code>Proxy</code> 可以在对象之前建立一层拦截层，用于处理对对象的访问。</p>
</li>
<li><p><strong>实现缓存</strong>：</p>
<p>可以使用 <code>Proxy</code> 来实现简单的缓存功能，当访问某些数据时，可以先检查缓存是否存在，减少对资源的访问。</p>
</li>
<li><p><strong>实现延迟操作</strong>：</p>
<p>可以通过 <code>Proxy</code> 在真正执行操作之前进行一些预处理，比如在访问某个属性时才进行真正的计算。</p>
</li>
</ol>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise **"></a>Promise **</h3><ul>
<li><p>Promise是ES6引入的异步编程的新解决方案，语法上Promise类似于一个构造函数，用来封装异步操作并可以获取成功或者失败的结果，专门用来解决回调地狱问题                                     </p>
</li>
<li><p>在这个Promise的参数中传递的是一个回调函数，用来监听异步的结果，在这个回调函数中有两个参数，分别是resolve和reject，这两个参数都是一个函数，分别代表成功和失败的回调参数，这两个参数调用时，都会返回到Promise调用一个Promise实例，该实例上有两个方法，分别是 then 和 catch，then方法对应的是resolve返回的实例，catch方法对应的是reject返回的实例</p>
</li>
<li><p>Promise.all()</p>
<p>   作用：并行操作异步处理，当我们需要同时发起多个异步请求时而且需要对请求的结果做处理，这时我们就要考虑使用all方法</p>
</li>
<li><p>三个状态：pending(进行中) 、fulfilled(成功)、rejected(失败)</p>
</li>
<li><p>特点</p>
<ul>
<li>1、对象状态不受外界影响</li>
<li>2、一旦状态改变，就不会再变，任何时候都可以得到这个结果</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>1、无法取消promise，一旦新建它就会立即执行，无法中途取消</li>
<li>2、如果不设置回调函数，promise内部抛出的错误，不会反应到外部</li>
<li>3、无法得知目前进展到哪一个阶段</li>
</ul>
</li>
</ul>
<h3 id="async和await是什么"><a href="#async和await是什么" class="headerlink" title="async和await是什么 **"></a>async和await是什么 **</h3><ul>
<li><p>async/await是基于Promise的语法糖，它提供了一种更为简洁和直观的方式来处理异步操作。通过在函数声明前加上<code>async</code>关键字，可以定义一个异步函数，并在其中使用<code>await</code>关键字来等待一个Promise对象的完成。使用<code>await</code>关键字可以暂停异步函数的执行，等待Promise对象的结果返回后再继续执行。</p>
<p>使用async/await可以使异步代码看起来更像是同步代码，提高了代码的可读性和维护性。同时，它也可以使用<code>try...catch</code>语句来处理异步操作的错误，使错误处理更加方便和直观。</p>
</li>
</ul>
<h3 id="async-await相比于Promise的优势？"><a href="#async-await相比于Promise的优势？" class="headerlink" title="async/await相比于Promise的优势？**"></a>async/await相比于Promise的优势？**</h3><ol>
<li><em><strong>代码结构更清晰</strong></em>：</li>
</ol>
<ul>
<li><code>async/await</code> 使得异步代码的写法更接近同步代码，更容易理解和阅读。</li>
<li>使用 <code>async</code> 声明异步函数，使用 <code>await</code> 等待异步操作的结果，让异步代码看起来像同步代码。</li>
</ul>
<ol start="2">
<li><em><strong>错误处理更简单</strong></em>：</li>
</ol>
<ul>
<li>使用 <code>try/catch</code> 可以非常方便地捕获异步函数中的错误，而不需要使用 <code>.catch()</code> 方法。</li>
<li>这使得错误处理更加直观和简单，减少了嵌套的回调函数。</li>
</ul>
<ol start="3">
<li><em><strong>更直观的调试</strong></em>：</li>
</ol>
<ul>
<li>在使用原生的 Promise 时，调试异步代码可能会变得复杂，因为异步操作被封装在 Promise 中，不容易跟踪。</li>
<li>使用 <code>async/await</code> 可以在代码中直接使用调试器，更方便地追踪代码执行的过程。</li>
</ul>
<ol start="4">
<li><em><strong>顺序控制更灵活</strong></em>：</li>
</ol>
<ul>
<li>使用 <code>await</code> 可以在异步代码中实现类似同步代码的顺序控制，可以等待前一个异步操作完成后再执行下一个操作。</li>
</ul>
<ol start="5">
<li><em><strong>适合处理异步操作链</strong></em>：</li>
</ol>
<ul>
<li>当有多个异步操作需要按顺序执行时，使用 <code>async/await</code> 可以让代码看起来更加清晰和简洁。</li>
<li>可以使用循环结构和条件语句等，灵活地控制异步操作的执行顺序。</li>
</ul>
<h3 id="同步与异步的区别"><a href="#同步与异步的区别" class="headerlink" title="同步与异步的区别"></a>同步与异步的区别</h3><p>同步：任务按照顺序执行，每个任务必须等待前一个任务完成之后才能开始执行，每个任务都会阻塞后续代码的执行，直到当前任务完成。                                                                                                                                  </p>
<p>异步：任务可以同时进行，不需要等待前一个任务完成。当一个异步任务开始执行后，程序不会等待其完成，而是立即转而执行后续的代码。</p>
<h3 id="常用的HTTP状态码"><a href="#常用的HTTP状态码" class="headerlink" title="常用的HTTP状态码"></a>常用的HTTP状态码</h3><ul>
<li>1XX：接受请求正在处理</li>
<li>2XX：请求正常处理完毕</li>
<li>3XX：需要附加操作已完成请求</li>
<li>4XX：服务器无法处理请求（客户端错误）</li>
<li>5XX：服务器处理请求错误（服务器错误）</li>
</ul>
<p>200    请求成功</p>
<p>204    无内容</p>
<p>206    服务器已经成功处理了部分GET请求。</p>
<p>301    永久重定向</p>
<p>302    临时重定向</p>
<p>303    查看其他地址</p>
<p>400    错误请求</p>
<p>401    请求要求用户的身份认证</p>
<p>403    拒绝请求</p>
<p>404    未找到</p>
<p>500    服务器内部错误，无法完成请求</p>
<p>503    服务器暂时不可用</p>
<h3 id="px、em、rem、vh、vw分别是什么"><a href="#px、em、rem、vh、vw分别是什么" class="headerlink" title="px、em、rem、vh、vw分别是什么"></a>px、em、rem、vh、vw分别是什么</h3><p>px：绝对长度单位，不会随着浏览器页面大小改变</p>
<p>em：相对长度单位，继承父元素的font-size，比如某个元素字体大小为16px，那么1em就等于16px</p>
<p>rem：相对长度单位，rem是相对于HTML根元素的字体大小来计算长度单位，</p>
<p>vh：表示视窗的高度的百分比，1vh表示视窗高度的1%</p>
<p>vw：表示视窗的宽度，1vw就表示视窗宽度的1%</p>
<h3 id="less和sass的区别-0"><a href="#less和sass的区别-0" class="headerlink" title="less和sass的区别          0"></a>less和sass的区别          0</h3><ul>
<li>Less和Sass是两种CSS预处理器，它们有以下区别：<ol>
<li>变量声明：Less使用@符号来声明变量，而Sass使用$符号来声明变量。</li>
<li>嵌套规则：Less不支持嵌套规则，而Sass支持嵌套规则。</li>
<li>运算符：Less的运算符使用斜杠（/）或空格（ ）进行分隔，而Sass使用冒号（:）进行分隔。</li>
<li>函数和混入：Less支持函数和混入，而Sass不支持。</li>
<li>颜色函数：Less支持颜色函数，而Sass不支持。</li>
<li>输出格式：Less没有输出格式，而Sass具有4种输出选项：nested、compact、compressed和expanded。</li>
<li>遍历数据：Less仅允许循环数值，而Sass可以遍历任何类型的数据。</li>
<li>外部CSS文件引用：在Sass中引用的外部文件命名必须以开头，而Less没有这个要求。</li>
<li>功能特性：Less有Preboot.less、Less Mixins、Less Elements、gs和Frameless等功能特性，而Sass有Compass。</li>
</ol>
</li>
</ul>
<h3 id="vue-router路由有几种模式？说说它们的区别"><a href="#vue-router路由有几种模式？说说它们的区别" class="headerlink" title="vue-router路由有几种模式？说说它们的区别"></a>vue-router路由有几种模式？说说它们的区别</h3><ol>
<li>原理不同：hash模式是通过监听hashChange事件来实现路由的，而history模式则是通过调用history.pushState或replaceState方法并监听popstate事件来实现路由的。</li>
<li>URL展示形式不同：在hash模式下，URL中会包含“#”号，而在history模式下，URL中不会出现“#”号。</li>
</ol>
<p>​    注意：默认为 hash 模式，在 VueRouter 实例中添加 mode 属性并设值为 ‘h istory’ 更改为 history 模式，此模式基于 html5</p>
<h3 id="vue路由传参的方式有哪些？如何接受传递的"><a href="#vue路由传参的方式有哪些？如何接受传递的" class="headerlink" title="vue路由传参的方式有哪些？如何接受传递的"></a>vue路由传参的方式有哪些？如何接受传递的</h3><ul>
<li>params 传参和 query 传参 <ul>
<li>静态路由通过 params 传参，页面一旦刷新则数据会丢失 动态路由刷新不会丢失数据 而 query 传参 刷新页面不会丢失数据</li>
<li>params 传参类似于 post 请求传参，参数不会出现在 url 地址中，可以使用this.$router.params来接收参数</li>
<li>query 传参类似于 get 传参，数据会以字符串形式暴露在 url 地址栏中，可以使用this.$route.query来接收参数</li>
</ul>
</li>
</ul>
<h3 id="路由的导航守卫"><a href="#路由的导航守卫" class="headerlink" title="路由的导航守卫"></a>路由的导航守卫</h3><ul>
<li>全局前置守卫 router.beforeEach()</li>
<li>全局后置守卫 router.afterEach()</li>
<li>全局解析守卫 router.beforeResolve()</li>
<li>路由独享守卫 beforeEnter:(to,from,next)=&gt;{}</li>
<li>beforeRouteEnter:()=&gt;{} 对访问用户进行权限校验</li>
<li>beforeRouteUpdate:()=&gt;{} 一般在动态路由的路径发生改变时，需要执行的操作</li>
<li>beforeRouterLeave:()=&gt;{} 通常情况下是为了预防用户还未保存前离开</li>
</ul>
<h3 id="说说vuex的工作流程"><a href="#说说vuex的工作流程" class="headerlink" title="说说vuex的工作流程"></a>说说vuex的工作流程</h3><ul>
<li>在组件中通过dispatch调用actions中的方法，在actions的方法中通过commit调用mutations中的方法，在mutations中借助于mutate来修改state中的数据，在state中的数据可以通过rander函数在组件中进行响应式渲染</li>
</ul>
<h3 id="mutations和actions的区别"><a href="#mutations和actions的区别" class="headerlink" title="mutations和actions的区别"></a>mutations和actions的区别</h3><ol>
<li>mutations只能处理同步任务，actions可以处理同步和异步</li>
<li>mutations方法中第一个参数是state对象，actions方法中第一个参数是store实例对象</li>
<li>mutations方法在组件中使用commit调用，actions方法在组件中使用dispatch</li>
<li>mutations方法在组件中无法使用then回调监听，actions方法在组件中可以使用then回调监听</li>
</ol>
<h3 id="Vuex的五大核心"><a href="#Vuex的五大核心" class="headerlink" title="Vuex的五大核心"></a>Vuex的五大核心</h3><ul>
<li>state：存放共用数据</li>
<li>mutations：唯一可以修改state状态的地方，也是可以保存所有同步方法的地方</li>
<li>actions：修改state中的数据，支持同步和异步</li>
<li>getters：获取state里的数据，如果需要对数据进行计算可以使用</li>
<li>models：Vuex模块化管理，也可以用来写数据，模块中的state允许有重名数据出现，但是mutations及actions中不允许有重名的方法名出现</li>
</ul>
<h3 id="Vuex中的辅助函数有哪些"><a href="#Vuex中的辅助函数有哪些" class="headerlink" title="Vuex中的辅助函数有哪些"></a>Vuex中的辅助函数有哪些</h3><ul>
<li>mapState：拿到vuex中state中的数据</li>
<li>mapMutations： 调用方法修改vuex中的属性，此方式修改可以实时更新vuex</li>
<li>mapActions： 类似于计算属性，在vuex中对数据进行操作并返回</li>
<li>mapGetters： 首先需要在vuex中定义getters，类似于计算属性，里面定义一个方法，需要返回一个值<br>，通过this.属性名调用</li>
</ul>
<h3 id="为什么v-if和v-for不建议用在同一标签"><a href="#为什么v-if和v-for不建议用在同一标签" class="headerlink" title="为什么v-if和v-for不建议用在同一标签"></a>为什么v-if和v-for不建议用在同一标签</h3><ul>
<li>1、性能损耗：v-for的优先级比v-if高，每次渲染都会先循环再进行条件判断</li>
<li>2、渲染结果：v-if会影响v-for的循环次数，导致列表渲染出错</li>
</ul>
<h3 id="什么是虚拟DOM，使用虚拟DOM的好处是"><a href="#什么是虚拟DOM，使用虚拟DOM的好处是" class="headerlink" title="什么是虚拟DOM，使用虚拟DOM的好处是?"></a>什么是虚拟DOM，使用虚拟DOM的好处是?</h3><ul>
<li>通过js创建一个Object对象来模拟真实DOM结构，这个对象包含标签名(tag)、属性(attrs)、和子元素对象(children)三个属性，通过vue中的render()函数把虚拟DOM编译成真实DOM，再通过appendChild()添加到页面中，Vue中的虚拟DOM最大的优势就是diff算法。减少JavaScript操作真实DOM带来的性能消耗 </li>
</ul>
<h3 id="set-方法的作用"><a href="#set-方法的作用" class="headerlink" title="$set 方法的作用"></a>$set 方法的作用</h3><ul>
<li> 当一个引用类型的数据添加新属性时，数据添加了 页面不会响应式改变，这时候我们可以通过this.$set方法进行新属性得添加，从而达到响应式变化的效果</li>
</ul>
<h3 id="refs-属性的作用"><a href="#refs-属性的作用" class="headerlink" title="$refs 属性的作用"></a>$refs 属性的作用</h3><ul>
<li>可以在组件名或标签名上添加一个ref属性，通过this.$refs.名字 可以获取对应的ref属性的组件或DOM元素</li>
</ul>
<h3 id="常见的Vue指令有哪些"><a href="#常见的Vue指令有哪些" class="headerlink" title="常见的Vue指令有哪些"></a>常见的Vue指令有哪些</h3><p>v-once：只会初始渲染一次数据，渲染完之后，该标签里面的数据不再进行响应式改变<br>v-html：可以解析数据中的HTML代码<br>v-text：不会解析HTMl代码，该标签内原有的内容会被替换掉<br>v-pre：不对具有v-pre属性的标签内容做解析<br>v-cloak：解决浏览器刷新时页面插值闪烁问题<br>v-bind：动态修改标签的属性<br>v-if：添加或删除元素，如果值为true 则表示添加元素 false表示删除<br>v-show：控制元素的显示与隐藏，<br>v-on：绑定事件 可以简写成@ 绑定的方法在methods中<br>v-for：列表渲染指令<br>  数据的类型：<br>  Array  数组<br>  Object 对象<br>  String 字符串<br>  Number 数字(必须是一个自然数，表示数组的长度)</p>
<h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><p><strong>虚拟 DOM</strong>：</p>
<p>在 Vue 中，每个组件都有一个对应的虚拟 DOM 树，它是一个轻量级的 JavaScript 对象树，用来描述组件的界面结构和状态。当数据发生变化时，Vue 会生成新的虚拟 DOM 树，然后通过比较新旧虚拟 DOM 树，找出需要更新的部分，最终只更新实际变化的部分。</p>
<p><strong>Diff 算法</strong>：</p>
<p>Diff 算法是用来比较新旧虚拟 DOM 树的一种高效的算法。它会在两棵树之间进行深度优先的遍历，同时进行节点的比较。</p>
<p>具体来说，Diff 算法会按照以下规则进行比较：</p>
<ol>
<li><strong>同层比较</strong>：首先会比较新旧虚拟 DOM 树的根节点，如果它们不相同，那么会直接替换整个节点及其子树。如果相同，则会继续比较子节点。</li>
<li><strong>同类型节点比较</strong>：如果两个节点是同一类型的，Vue 会更新它们的属性和事件，而不会重新创建节点。这样可以保留节点的状态，提高更新效率。</li>
<li><strong>列表节点比较</strong>：当处理列表时，Diff 算法会采用一种类似“key”的策略，尽可能复用相同 key 的节点，减少 DOM 操作。</li>
<li><strong>递归比较子节点</strong>：Diff 算法会递归地比较新旧节点的子节点，从而找到需要更新的部分。</li>
</ol>
<p>Diff 算法通过以上规则，尽量减少了实际的 DOM 操作，只对实际发生变化的部分进行更新，从而提高了性能。</p>
<p>总的来说，Vue 的虚拟 DOM 和 Diff 算法是为了优化视图更新性能而设计的，通过最小化实际的 DOM 操作，使得应用可以更高效地响应数据的变化。</p>
<h3 id="你知道vue中key的原理吗？说说你对它的理解"><a href="#你知道vue中key的原理吗？说说你对它的理解" class="headerlink" title="你知道vue中key的原理吗？说说你对它的理解"></a>你知道vue中key的原理吗？说说你对它的理解</h3><p><code>key</code> 是 Vue 中用于帮助 Vue 识别节点的一个特殊属性。它主要用于在使用 <code>v-for</code> 进行列表渲染时，帮助 Vue 更高效地更新虚拟 DOM。</p>
<p>具体来说，<code>key</code> 的作用是：</p>
<ol>
<li><strong>节点的唯一标识</strong>：<code>key</code> 提供了一种节点的唯一标识，使得 Vue 能够准确追踪每个节点的变化，从而提高了更新的效率。</li>
<li><strong>在列表中重新排序元素</strong>：当数据源发生变化时，如果列表中的某些项的 <code>key</code> 发生了变化，Vue 会将其视为全新的项，进行重新渲染，而不是进行复杂的比较和移动操作。</li>
<li><strong>避免复用节点引发的问题</strong>：如果不使用 <code>key</code>，在列表中插入、删除、排序等操作时，Vue 可能会出现复用节点的情况，导致界面显示不正确或出现奇怪的问题。</li>
</ol>
<p>需要注意的是：</p>
<ul>
<li><code>key</code> 应该是唯一且稳定的，不建议使用随机数或者索引作为 <code>key</code>。</li>
<li>不推荐在组件根元素上使用 <code>key</code>，因为它不会对组件的行为产生影响。</li>
</ul>
<h3 id="vue组件传值"><a href="#vue组件传值" class="headerlink" title="vue组件传值"></a>vue组件传值</h3><p><strong>父传子</strong>：在父组件的子组件标签上自定义一个属性，属性值就是给子组件传递的数据，在子组件通过 props 属性来接收父组件传递过来的数据</p>
<p><strong>子传父</strong>：子组件中使用$emit方法触发自定义事件并同时携带数据，并在父组件中监听该事件来接收子组件传递的数据。</p>
<p><strong>非父子</strong>：在父组件中使用provide提供数据，然后在子组件中使用inject来注入这些数据，子组件就可以访问和使用这些数据。这种方式可以跨越组件层级，实现非父子组件之间的数据传递。</p>
<p><strong>$bus（事件总线）</strong>：</p>
<p>新建一个bus.js文件，该文件需要导出一个空的vue实例</p>
<p>将bus.js引入到main.js中，并将bus空实例挂载到Vue的原型对象中</p>
<p>在需要传出数据的组件中使用this.<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="3.955ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 1748 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1001,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mo" transform="translate(1470,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g></g></g></svg></mjx-container>emit()来发出自定义事件并传值</p>
<p>在需要接收数据的组件中使用this.<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="3.955ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 1748 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1001,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mo" transform="translate(1470,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g></g></g></svg></mjx-container>on()来监听自定义事件并接收值</p>
<h3 id="spa单页面"><a href="#spa单页面" class="headerlink" title="spa单页面"></a>spa单页面</h3><p>SPA是指单页面应用程序，是一种现代应用程序开发模式。</p>
<p>SPA是在初始加载时，将整个应用程序的代码和资源一次性加载到浏览器中，之后的导航和页面更新都在客户端进行处理，通过动态地更新DOM和交互来呈现内容。这样可以避免每次导航都需要重新加载整个页面，提供了更流畅、快速的用户体验。</p>
<p>SPA通常使用JavaScript框架（如Vue.js、React、Angular等）来实现，它们提供了路由管理、组件化开发、数据响应式等功能，使得开发单页面应用变得更加高效和便捷。</p>
<p>SPA的特点包括：</p>
<ul>
<li>单页面：整个应用程序只有一个HTML页面，通过动态更新内容来呈现不同的视图。</li>
<li>前后端分离：前端负责处理用户交互和视图渲染，后端提供API接口和数据。</li>
<li>路由管理：通过前端路由实现不同页面间的切换和导航。</li>
<li>异步加载：按需加载资源，减少初始加载时间。</li>
<li>数据响应式：通过响应式框架实现数据的双向绑定和更新。</li>
</ul>
<h3 id="keep-alive是什么"><a href="#keep-alive是什么" class="headerlink" title="keep-alive是什么"></a>keep-alive是什么</h3><p>在Vue.js中，<code>keep-alive</code>是一个内置组件，用于在多个组件之间动态切换时，条件性地缓存组件实例。它的作用是通过保留组件的状态来提高性能，而不是在组件被切换关闭和重新打开时销毁和重新创建。</p>
<p>当一个组件被包裹在<code>keep-alive</code>组件中时，它会被保留在当前状态下，而不是在切换关闭和再次打开时被销毁和重新创建。这意味着组件的数据、计算属性和组件生命周期钩子将被保留。</p>
<p>以下是关于Vue.js中<code>keep-alive</code>的一些关键点：</p>
<ul>
<li><code>keep-alive</code>不会被渲染为DOM元素，也不会在DOM中显示为一个组件。</li>
<li>它是一个抽象元素，在后台工作，用于缓存和保留组件实例。</li>
<li>缓存的组件实例被存储在内存中，可以在需要时快速重新激活。</li>
<li><code>keep-alive</code>可以与动态组件一起使用，允许在不同的组件之间切换，并保留它们的状态。</li>
<li>在组件具有昂贵的初始化或重度渲染的情况下，使用<code>keep-alive</code>可以避免每次切换时重新创建它们的开销。</li>
</ul>
<p>总的来说，<code>keep-alive</code>是Vue.js中一个强大的功能，通过缓存和重用组件实例来优化性能。</p>
<h3 id="nextTick和-nextTick在-Vue-js-中的作用如下："><a href="#nextTick和-nextTick在-Vue-js-中的作用如下：" class="headerlink" title="nextTick和 $nextTick在 Vue.js 中的作用如下："></a>nextTick和 $nextTick在 Vue.js 中的作用如下：</h3><ol>
<li><code>nextTick</code>：<code>nextTick</code> 是 Vue 提供的一个异步方法，用于在 DOM 更新之后执行特定的操作，以确保在更新后执行一些操作，比如获取更新后的 DOM 元素尺寸或执行其他需要在 DOM 更新后进行的任务。</li>
<li><code>$nextTick</code>：vue是异步渲染的框架，data改变以后，dom不会立刻渲染，$nextTick会在dom渲染之后被触发，以获取最新dom节点</li>
</ol>
<p><code>nextTick</code> 和 <code>$nextTick</code> 的目的都是确保在 Vue.js 中的数据更改后，正在使用最新的 DOM。它们通常用于在数据更改后访问或操作 DOM。</p>
<h3 id="data为什么是个函数，不能是个对象"><a href="#data为什么是个函数，不能是个对象" class="headerlink" title="data为什么是个函数，不能是个对象"></a>data为什么是个函数，不能是个对象</h3><ul>
<li><code>data</code>被定义为一个函数而不是一个对象的原因是为了实现组件复用。对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他复用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。</li>
</ul>
<h3 id="v-model原理是什么"><a href="#v-model原理是什么" class="headerlink" title="v-model原理是什么"></a>v-model原理是什么</h3><p>通过v-bind绑定输入框的value值实现数据改变输入框内容跟着改变，再通过v-on监听输入框的input事件，在事件函数中获取输入框的value来改变数据，从而达到双向绑定的实现</p>
<h3 id="如何在Vue-js中实现双向数据绑定？"><a href="#如何在Vue-js中实现双向数据绑定？" class="headerlink" title="如何在Vue.js中实现双向数据绑定？"></a>如何在Vue.js中实现双向数据绑定？</h3><p>vue.js 采用数据劫持结合发布者-订阅者模式的方式 通过 Object.defineProperty()来劫持各个数据的 setter 和 getter 数据变动时发布消息给订阅者 触发相应的监听回调来渲染视图 </p>
<h3 id="vue中生命周期函数有哪些"><a href="#vue中生命周期函数有哪些" class="headerlink" title="vue中生命周期函数有哪些"></a>vue中生命周期函数有哪些</h3><p>Vue生命周期分为4个大的阶段<br>初始化、挂载、更新、销毁 触发八个生命周期函数<br>beforeCreate ：  初始化前<br>  vue实例开始准备加载data/methods….<br>created : 初始化后<br>  vue已经加载完data/methods….<br>  进行网络请求，拿到页面数据<br>beforeMount ： 挂载前<br>  将vue实例挂载到某个DOM元素前<br>mounted ： 挂载后<br>   将vue实例挂载某个DOM元素完成,这时才可以对DOM进行操作<br>beforeUpdate ： 更新前<br>updated ： 更新后<br>beforeDestroy ： 销毁前<br>destroyed ： 销毁后</p>
<h3 id="vue中computed、watch、method的区别？"><a href="#vue中computed、watch、method的区别？" class="headerlink" title="vue中computed、watch、method的区别？"></a>vue中computed、watch、method的区别？</h3><ol>
<li>Computed属性是Vue.js中用于计算属性的函数，它根据依赖的数据进行缓存，只有当依赖的数据发生改变时才会重新计算。它与methods和watch的区别在于它是基于依赖数据进行计算，而不是执行函数。与methods不同的是，computed属性可以设置getter和setter方法，用于读取和修改数据。而watch属性则用于观察某个数据的改变，并执行相应的回调函数。</li>
</ol>
<h3 id="前端页面渲染的优化方式有哪些"><a href="#前端页面渲染的优化方式有哪些" class="headerlink" title="前端页面渲染的优化方式有哪些"></a>前端页面渲染的优化方式有哪些</h3><ol>
<li><strong>减少HTTP请求</strong>：合并CSS和JavaScript文件，使用雪碧图、字体图标等技术来减少页面所需的HTTP请求次数。</li>
<li><strong>使用CDN（内容分发网络）</strong>：将静态资源部署到CDN上，可以加速资源的加载速度。</li>
<li><strong>延迟加载（懒加载）</strong>：对于非首屏必要的资源，可以延迟加载，等到用户需要时再加载，如图片懒加载、异步加载。</li>
<li><strong>使用缓存</strong>：利用浏览器缓存机制，对于不经常变动的资源可以设置合适的缓存策略，减少重复加载。</li>
<li><strong>优化图片</strong>：使用合适的图片格式，对图片进行压缩处理，以减少页面的加载时间。</li>
<li><strong>精简和压缩代码</strong>：删除不必要的空格、注释等，使用压缩工具对HTML、CSS、JavaScript进行压缩，减小文件大小。</li>
<li><strong>使用外部JavaScript和CSS</strong>：将JavaScript和CSS代码放在外部文件中，可以提高缓存效率，同时也使得HTML文件更加清晰。</li>
<li><strong>避免使用同步加载的资源</strong>：避免使用<code>&lt;script&gt;</code>标签的<code>async</code>和<code>defer</code>属性，以免阻塞页面的加载。</li>
<li><strong>使用字体图标</strong>：使用字体图标（如Font Awesome）来代替大量小图标的图片，减少HTTP请求。</li>
<li><strong>减少DOM操作</strong>：避免频繁对DOM进行操作，可以先将需要操作的DOM节点存储在变量中，减少查找和操作的次数。</li>
<li><strong>避免重复绘制</strong>：使用CSS中的<code>will-change</code>属性或<code>transform</code>、<code>opacity</code>等属性，避免频繁触发回流和重绘。</li>
<li><strong>优化动画效果</strong>：使用GPU加速的动画效果，避免使用影响性能的动画，如大量使用<code>position: absolute</code>等属性。</li>
<li><strong>利用浏览器的缓存</strong>：合理设置响应头中的缓存控制，利用浏览器的缓存机制减少不必要的资源请求。</li>
<li><strong>使用WebP格式图片</strong>：对于支持WebP格式的浏览器，可以使用WebP格式的图片，它具有更高的压缩率。</li>
<li><strong>利用预加载和预渲染</strong>：使用<code>&lt;link rel="preload"&gt;</code>或<code>&lt;link rel="prerender"&gt;</code>来提前加载关键资源或页面。</li>
<li><strong>使用服务端渲染（SSR）</strong>：对于需要SEO优化或提高首屏加载速度的页面，可以考虑使用服务端渲染技术。</li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6(未总结完)</title>
    <url>/2023/06/02/ES6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>ES6声明变量的六种方法</strong></p>
<p>var，function，let，const，import，class</p>
<p><strong>let,var,const 区别</strong></p>
<p>var：预解析 变量提升 只提升变量名 不提升赋值，产生作用域</p>
<p>let 定义的变量不进行预解析，不进行变量提升，产生块级作用域{}</p>
<p>const 声明一个只读常量。一旦声明，常量的值就不能改变。(栈中的值)</p>
<p><strong>箭头函数</strong></p>
<p>​    1. 省略function关键字，在()和{}之间使用一个箭头连接</p>
<p>​    2. 当形参有且只有一个的时候，()也可以省略不写</p>
<span id="more"></span>

<p>​    3. 当函数体中有且只有一条return语句时，可以省略{}及return关键字</p>
<p>​    4. 没有自己的this指向,会查找父级作用域的this</p>
<p>​    5. 没有arguments实参的集合</p>
<ol start="6">
<li><p>因为没有自己的this，所以不能作为构造函数使用</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn8</span>(<span class="params"></span>){</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>) <span class="comment">// Arguments(8) [1, 2, 3, 4, 5, 6, 7, 8, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line">   <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span>  i = <span class="number">0</span> ; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span> ; i++){</span><br><span class="line">​    sum += <span class="variable language_">arguments</span>[i]</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> sum</span><br><span class="line">  }</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn8</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)) <span class="comment">// 结果是36</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 箭头函数没有arguments实参的集合</span></span><br><span class="line">  <span class="keyword">var</span> <span class="title function_">fn9</span> = (<span class="params"></span>) =&gt; {</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>) <span class="comment">// arguments is not defined</span></span><br><span class="line">   <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span>  i = <span class="number">0</span> ; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span> ; i++){</span><br><span class="line">​    sum += <span class="variable language_">arguments</span>[i]</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> sum</span><br><span class="line">  }</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn9</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>))</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p><strong>剩余运算符（扩展运算符）…</strong></p>
<p>…(剩余运算符)的作用</p>
<p>分配不了的都给它</p>
<p>当剩余运算符在函数的形参中使用时，只允许出现在最后一个形参前面，表示剩下所有传递的实参都保存在这个参数中，以数组形式展示</p>
<p>剩余运算符还可以作为展开数组的作用来使用，这时我们一般称之为开展运算符，或者扩展运算符，可以利用这种语法实现</p>
<p>例如：数组合并 ，伪数组转换为真数组 等使用场景</p>
<p>当我们需要将一个数组的每一个项作为实参的每一个值传递时，最简单的方式就是使用扩展运算符</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> arr3 = arr1.<span class="title function_">concat</span>(arr2) <span class="comment">// 合并数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment">// 使用扩展运算符合并</span></span><br><span class="line"><span class="keyword">var</span> arr4 = [...arr1,...arr2]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr4) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用扩展运算符找数组中最大值</span></span><br><span class="line"><span class="keyword">var</span> arr7 = [<span class="number">13</span>,<span class="number">21</span>,<span class="number">3</span>,<span class="number">3124</span>,<span class="number">32</span>,<span class="number">4532</span>,<span class="number">5</span>] </span><br><span class="line"><span class="keyword">let</span> maxNum = <span class="title class_">Math</span>.<span class="title function_">max</span>(...arr7)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(maxNum) <span class="comment">// 4532</span></span><br></pre></td></tr></table></figure></div>

<p><strong>模板字符串</strong></p>
<p>   使用反引号创建的字符串就是模板字符串 ``</p>
<p>​    * 模板字符串中的内容允许直接换行</p>
<p>​    * 解决了字符串和变量之间使用+拼接的繁琐工作，可以直接使用${}来识别变量</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello  word"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> str1 = <span class="string">`hello </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  word`</span></span><br></pre></td></tr></table></figure></div>

<p><strong>结构赋值</strong></p>
<p>在ES6中允许按照一定的模式从数组或者对象中提取想要的数据</p>
<p>左右两边的结构必须保持一致</p>
<p>声明和赋值不能分开</p>
<p>将繁琐的数据进行简单化处理</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的结构赋值</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">"张三"</span>, <span class="string">"李四"</span>, <span class="string">"王五"</span>]</span><br><span class="line"><span class="keyword">var</span> [a, b, ...c] = arr</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 张三</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// 李四</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">// Array(1) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的结构赋值</span></span><br><span class="line"><span class="comment">// 对象的属性名和解构的变量名一一对应</span></span><br><span class="line">  <span class="keyword">var</span> obj = {</span><br><span class="line">    <span class="attr">name</span>: <span class="string">"张三"</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="string">"19"</span>,</span><br><span class="line">    <span class="attr">job</span>: <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"web前端"</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">var</span> { name, job,age } = obj</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">// 张三</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(age)  <span class="comment">// 19</span></span><br><span class="line">  <span class="title function_">job</span>() <span class="comment">// web前端</span></span><br></pre></td></tr></table></figure></div>



<p><strong>Symbol数据类型</strong></p>
<p>​    ES6引入一个全新的数据类型 Symbol该类型表示独一无二的值，类型的展现方式类似于字符串</p>
<p>​     特点：</p>
<p>​      1） Symbol值是唯一的，那么可以解决命名冲突问题</p>
<p>​      2） Symbol值不能和其他任何数据进行计算</p>
<p>​      3） Symbol定义的对象属性不能使用for in进行遍历 =，Reflect.ownkeys来获取所有的键名</p>
<p>​    Symbol()表示创建一个独一无二的值</p>
<p>​    Symbol.for()表示创建一个独一无二的地址</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="comment">// Symbol()表示创建一个独一无二的值</span></span><br><span class="line"><span class="comment">// Symbol.for()表示创建一个独一无二的地址</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1) <span class="comment">// Symbol()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> s1) <span class="comment">//验证是symbol类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  s2 = <span class="title class_">Symbol</span>(<span class="string">"北工商"</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2) <span class="comment">// Symbol(北工商)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s3 = <span class="title class_">Symbol</span>(<span class="string">"北工商"</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2==s3) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s4 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">"北工商"</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s4) <span class="comment">//Symbol(北工商)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> s4) <span class="comment">//symbol</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2==s4) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s5 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">"北工商"</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s5==s4) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s4.<span class="property">name</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s5.<span class="property">name</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></div>

<p><strong>迭代器（iterator）</strong></p>
<p>​    迭代器就是一个接口，为各种不同的数据结构提供一种统一的访问机制，任何数据结构只要部署了iterator结构，那么就可以完成访问操作</p>
<p>​    在ES6创造了一种全新的遍历命令，for of，只要有iterator结构数据结构就可以使用for of进行遍历操作</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>​    默认情况下 for of 是无法遍历对象的，因为对象的原型上没有部署iterator接口</p>
<p>   * 工作原理</p>
<p>​    1. 创建一个指针对象，指向当前数据的起始位置</p>
<p>​    2. 第一次调用对象的next()方法，指针会自动指向该数据的下一个成员</p>
<p>​    3. 接下来就是不断地调用next()方法，指针一直向后移动，一直到移动到最后一个成员</p>
<p>​    4. 每一次调用next()方法时，会返回一个包含value和done两个属性的对象，其中value表示指针指向的数据，done表示是否完成</p>
<p>​    5. 当执行到value的值为undefined时候，done的值就会变成true，当done值为true时，next()调用就会终止</p>
<p>   * 使用场景</p>
<p>​     当我们需要在自定义遍历数据的时候，我们想到的就是迭代器</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span>  str = <span class="string">"hello world"</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> str){</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> obj = {</span><br><span class="line">  <span class="attr">name</span>:<span class="string">"张三"</span></span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// for(var item of obj){</span></span><br><span class="line"> <span class="comment">//  console.log(item)</span></span><br><span class="line"> <span class="comment">// }</span></span><br><span class="line"> <span class="comment">//  obj is not iterable  Object没有iterable方法</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> arr = [<span class="string">"独行月球"</span>,<span class="string">"疯狂外星人"</span>,<span class="string">"疯狂的石头"</span>,<span class="string">"疯狂原始人"</span>]</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr){</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">var</span> it = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(it) <span class="comment">// Array Iterator {}</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">//{value: '独行月球', done: false}</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">//{value: '疯狂外星人', done: false}</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">//{value: '疯狂的石头', done: false}</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">//{value: '疯狂原始人', done: false}</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">//{value: undefined, done: true}</span></span><br></pre></td></tr></table></figure></div>

<p><strong>Promise</strong></p>
<p> Promise是ES6引入的异步编程的新解决方案，语法上Promise类似于一个构造函数，用来封装异步操作并可以获取成功或者失败的结果，专门用来解决回调地狱问题</p>
<p> 在Promise的参数中传递的是一个回调函数，用来监听异步的结果，在这个回调函数中有两个参数，分别是resolve，reject </p>
<p> resolve和reject 两个参数都是一个函数，分别表示成功和失败的回调参数</p>
<p> 这两个参数调用时都会返回到Promise调用处一个Promise实例，该实例上有两个方法，分别是then 和 catch</p>
<p>  then方法对应的是resolve返回的实例</p>
<p>  catch方法对应的是reject返回的实例</p>
<p>  then方法中可以接收两个参数，第一个参数是成功的回调，第二个参数则是失败的回调，</p>
<p>  也就是说如果我们不想写catch 那么可以将catch的内容写在then方法的第二个参数中</p>
<p>  <strong>Promise.all()</strong></p>
<p>   作用：并行操作异步处理，当我们需要同时发起多个异步请求时而且需要对请求的结果做处理，这时我们就要考虑使用all方法</p>
<p>  <strong>Promise有三个状态</strong></p>
<p>   初始态：pending</p>
<p>   在Promise中没有执行resolve 或者 reject的状态</p>
<p>   成功态：fulfilled</p>
<p>   失败态：rejected</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve,reject</span>){</span><br><span class="line">   <span class="comment">// if(num &lt; 2){</span></span><br><span class="line">   <span class="comment">//  resolve('成功')</span></span><br><span class="line">   <span class="comment">// }else{</span></span><br><span class="line">   <span class="comment">//  reject('失败')</span></span><br><span class="line">   <span class="comment">// }</span></span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 写一些异步操作</span></span><br><span class="line">​    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>{</span><br><span class="line">​     <span class="keyword">var</span> data = <span class="string">"请求到的数据"</span></span><br><span class="line">​     <span class="title function_">resolve</span>(data)</span><br><span class="line">​     <span class="title function_">reject</span>(<span class="string">"err"</span>)</span><br><span class="line">​    },<span class="number">2000</span>)</span><br><span class="line">  })</span><br><span class="line"></span><br><span class="line">  p.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>{</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  })</span><br><span class="line"></span><br><span class="line">  p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>{</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  })</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>集合：Map Set</strong> </p>
<p>   ES6提供了新的数据结构Set，类似于数组，但是具有成员唯一性的特性</p>
<p>   访问Set集合中的数据可以使用 for of 遍历来访问</p>
<p>**Set主要的应用场景在于 数据重组  **</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// size返回集合元素的个数</span></span><br><span class="line"><span class="comment">// add() ：为当前集合新增一个新的成员,返回当前集合</span></span><br><span class="line"><span class="comment">// delete() : 为当前集合删除一个指定成员,返回boolean值</span></span><br><span class="line"><span class="comment">// clear() : 清空集合,返回undefined</span></span><br><span class="line"><span class="comment">// hsa() : 检测集合中是否存在某个成员，返回Boolean类型的</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">"111"</span>,<span class="string">"222"</span>,<span class="string">"333"</span>,<span class="string">"111"</span>])</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s1) <span class="comment">// Set(3) {'111', '222', '333'}</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">size</span>) <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> s1){</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 111 222 333 </span></span><br><span class="line">  }</span><br><span class="line">  s1.<span class="title function_">add</span>(<span class="string">"444"</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s1) <span class="comment">// Set(4) {'111', '222', '333', '444'}</span></span><br><span class="line">  s1.<span class="title function_">delete</span>(<span class="string">"222"</span>) <span class="comment">// Set(3) {'111', '333', '444'}</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s1)</span><br><span class="line">  s1.<span class="title function_">clear</span>() </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s1) <span class="comment">// Set(0) {size: 0}</span></span><br><span class="line">  <span class="keyword">var</span> boo = s1.<span class="title function_">has</span>(<span class="string">"444"</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(boo) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set的值是唯一的 不可以重复且自动排序</span></span><br><span class="line">  <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">65</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line">  <span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="title class_">Set</span>(arr)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s2) <span class="comment">// Set(6) {1, 2, 4, 65, 7, …}</span></span><br><span class="line">  <span class="keyword">var</span> arr2 = [...s2]</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arr2) <span class="comment">// (6) [1, 2, 4, 65, 7, 8]</span></span><br></pre></td></tr></table></figure></div>

<p> <strong>Map 主要的应用场景在于数据储存</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map: </span></span><br><span class="line"><span class="comment">// ES6提出的心的数据结构，类似于对象，也是键值对的集合</span></span><br><span class="line"><span class="comment">// set() ：为集合添加新的成员，返回添加后的集合</span></span><br><span class="line"><span class="comment">// get() : 获取对应键名的值</span></span><br><span class="line"><span class="comment">// has() : 判断集合中是否存在某个成员 返回 boolean 值</span></span><br><span class="line"><span class="comment">// size() ：返回 Map 的元素个数</span></span><br><span class="line"><span class="comment">// clear() : 清空集合，返回 undefined</span></span><br><span class="line"><span class="comment">// delete(): 通过键值从Map中移除对应的数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  m1.<span class="title function_">set</span>(<span class="string">'name'</span>,<span class="string">"张三"</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(m1) </span><br><span class="line">  <span class="comment">// Map(1) {'name' =&gt; '张三'}</span></span><br><span class="line">  <span class="comment">// key: "name"</span></span><br><span class="line">  <span class="comment">// value: "张三"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    m1.<span class="title function_">set</span>(<span class="string">'name'</span>,<span class="string">"张三"</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(m1)</span><br><span class="line">		<span class="comment">// Map(1) {'name' =&gt; '张三'}</span></span><br><span class="line">  		<span class="comment">// key: "name"</span></span><br><span class="line">  		<span class="comment">// value: "张三"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> key = {</span><br><span class="line">      <span class="attr">school</span>:<span class="string">"北工商"</span>,</span><br><span class="line">    }</span><br><span class="line">    m1.<span class="title function_">set</span>(key,[<span class="string">'北京'</span>,<span class="string">"上海"</span>])</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(m1)</span><br><span class="line">	<span class="comment">//对象相同的键连续赋值，后一次的值会覆盖前一次的值</span></span><br><span class="line">	<span class="comment">//注意:只有对同一个对象的引用，Map结构才将其视为同一个键，引用数据类型必须内存地址一样，才可能是同一个键</span></span><br><span class="line">		<span class="comment">// 0: {"name" =&gt; "张三"}</span></span><br><span class="line">		<span class="comment">// key: "name"</span></span><br><span class="line">  		<span class="comment">// value: "张三"</span></span><br><span class="line">        <span class="comment">// 1: {Object =&gt; Array(2)}</span></span><br><span class="line">		<span class="comment">// key: {school: '北工商'}</span></span><br><span class="line">  		<span class="comment">// value: (2) ['北京', '上海']</span></span><br><span class="line"></span><br><span class="line">    m1.<span class="title function_">set</span>([<span class="string">"name1"</span>,<span class="string">"李四"</span>])</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(m1)</span><br><span class="line">	<span class="comment">// 如果读取一个未知的键，则返回undefined</span></span><br><span class="line">		<span class="comment">// 0: {"name" =&gt; "张三"}</span></span><br><span class="line">		<span class="comment">// key: "name"</span></span><br><span class="line">  		<span class="comment">// value: "张三"</span></span><br><span class="line">        <span class="comment">// 1: {Object =&gt; Array(2)}</span></span><br><span class="line">		<span class="comment">// key: {school: '北工商'}</span></span><br><span class="line">  		<span class="comment">// value: (2) ['北京', '上海']</span></span><br><span class="line">		<span class="comment">// 2: {Array(2) =&gt; undefined}</span></span><br><span class="line">		<span class="comment">// key: (2) ['name1', '李四']</span></span><br><span class="line">		<span class="comment">// value: undefined</span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>回流与重绘</title>
    <url>/2022/11/15/ReflowandRepaint/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr>
<p><strong>在回流和重绘之前先来了解一下的浏览器的渲染过程</strong></p>
<ol>
<li><strong>解析HTML文件</strong>，构建DOM树（Document Object Model），表示页面的结构和内容。</li>
<li><strong>解析CSS文件</strong>，构建CSSOM树（CSS Object Model），表示页面的样式和布局。</li>
<li><strong>合并DOM树和CSSOM树</strong>，生成渲染树（Render Tree），表示页面的可见元素和属性。</li>
<li><strong>布局渲染树</strong>，计算每个元素的位置和大小，生成布局（Layout）。</li>
<li><strong>绘制渲染树</strong>，将每个元素绘制到屏幕上，生成像素（Paint）。</li>
<li><strong>合成图层</strong>，将多个图层合并为一张位图，显示在屏幕上（Composite）。</li>
</ol>
<p>在这个过程中，还可能涉及到<strong>加载图片等资源文件</strong>和<strong>执行解析js文件脚本代码</strong>等操作，这些操作可能会影响DOM树、CSSOM树或渲染树的更新，从而触发重排（Reflow）或重绘（Repaint）。</p>
<span id="more"></span>

<p>Reflow（回流)：在render树的基础上进行布局, 计算每个节点的大小和位置。</p>
<p>Repaint（重绘）：根据渲染树以及回流得到的几何信息，把每个节点绘制在屏幕上。</p>
<p><strong>什么是回流</strong></p>
<p>当render树中的一部分元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受到影响的部分到屏幕中，此过程叫重绘。因此回流必然会引起重绘。</p>
<p><strong>什么是重绘</strong></p>
<p>当render树中的一些元素的某些属性发生改变时，而这些属性只是影响元素的外观，风格，而不会影响布局，比如background-color。这就称为重绘（repaint）。重绘不一定会引起回流。</p>
<p><strong>区别</strong></p>
<p>回流必将引起重绘，而重绘不一定会引起回流。</p>
<p>比如：只有颜色改变的时候就只会发生重绘而不会引起回流，而当页面布局和几何属性改变时就需要回流。display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发生位置变化。</p>
<p>所以我们能得知回流的成本要高于重绘，回流的花销跟render树有多少节点需要重新构建有关系。</p>
<p>下面这些原因会引起浏览器的回流：<br>调整窗口大小，改变字体大小，CSS伪类激活（在用户交互过程中发生），添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变等。</p>
<h2 id="如何减少回流和重绘"><a href="#如何减少回流和重绘" class="headerlink" title="如何减少回流和重绘"></a>如何减少回流和重绘</h2><p>1.浏览器中的优化机制</p>
<p>浏览器会维护一个队列，队列中存放的是会触发回流和重绘的操作，当队列中的操作达到一定阀值或者到了一定的时间间隔时，浏览器就会清空队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。但是！当你获取元素大小和位置等布局信息的时候，比如当你访问offsetTop、scrollTop、clientTop这些属性或者使用getComputedStyle()、getBoundingClientRect（）等方法的时候，为了保证准确（得到最新的布局信息），队列会被强制清空，触发回流重绘来返回正确的值。因此，要注意这一类操作的使用！如果要使用它们，最好将值缓存起来。</p>
<p>2.自己进行优化</p>
<p>核心在于减少Repaint和Reflow的次数</p>
<p>Repaint和Reflow是不可避免的，只能说对性能的影响减到最小，给出下面几条建议：</p>
<ol>
<li>改变样式的时候，避免逐条更改样式，而是集中修改样式，例如操作className或使用cssText。</li>
<li>避免频繁读取元素几何属性（例如scrollTop）。</li>
<li>使用定位让元素脱离文档流。</li>
<li>开启css3硬件加速。</li>
<li>可以通过批量修改dom元素的方式达到减少回流和重绘的目的，具体有以下三种方式： </li>
</ol>
<ul>
<li>在设置display:none;的元素上操作，最后显示出来</li>
<li>使用文档片段(document fragment)，在当前DOM外构建一个子树，在它上面应用所有DOM操作，再把它拷贝回文档。</li>
<li>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
